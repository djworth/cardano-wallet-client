// Package wallet provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package wallet

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAnyAddress request  with any body
	PostAnyAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnyAddress(ctx context.Context, body PostAnyAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InspectAddress request
	InspectAddress(ctx context.Context, addressId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListByronWallets request
	ListByronWallets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostByronWallet request  with any body
	PostByronWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostByronWallet(ctx context.Context, body PostByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteByronWallet request
	DeleteByronWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronWallet request
	GetByronWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutByronWallet request  with any body
	PutByronWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutByronWallet(ctx context.Context, walletId string, body PutByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListByronAddresses request
	ListByronAddresses(ctx context.Context, walletId string, params *ListByronAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAddress request  with any body
	CreateAddressWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAddress(ctx context.Context, walletId string, body CreateAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportAddresses request  with any body
	ImportAddressesWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportAddresses(ctx context.Context, walletId string, body ImportAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportAddress request
	ImportAddress(ctx context.Context, walletId string, addressId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListByronAssets request
	ListByronAssets(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronAssetDefault request
	GetByronAssetDefault(ctx context.Context, walletId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronAsset request
	GetByronAsset(ctx context.Context, walletId string, policyId string, assetName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByronSelectCoins request  with any body
	ByronSelectCoinsWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ByronSelectCoins(ctx context.Context, walletId string, body ByronSelectCoinsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronWalletMigrationInfo request
	GetByronWalletMigrationInfo(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateByronWallet request  with any body
	MigrateByronWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateByronWallet(ctx context.Context, walletId string, body MigrateByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutByronWalletPassphrase request  with any body
	PutByronWalletPassphraseWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutByronWalletPassphrase(ctx context.Context, walletId string, body PutByronWalletPassphraseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostByronTransactionFee request  with any body
	PostByronTransactionFeeWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostByronTransactionFee(ctx context.Context, walletId string, body PostByronTransactionFeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronUTxOsStatistics request
	GetByronUTxOsStatistics(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListByronTransactions request
	ListByronTransactions(ctx context.Context, walletId string, params *ListByronTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostByronTransaction request  with any body
	PostByronTransactionWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostByronTransaction(ctx context.Context, walletId string, body PostByronTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteByronTransaction request
	DeleteByronTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetByronTransaction request
	GetByronTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkClock request
	GetNetworkClock(ctx context.Context, params *GetNetworkClockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkInformation request
	GetNetworkInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkParameters request
	GetNetworkParameters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExternalTransaction request  with any body
	PostExternalTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutSettings request  with any body
	PutSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutSettings(ctx context.Context, body PutSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSharedWallet request  with any body
	PostSharedWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSharedWallet(ctx context.Context, body PostSharedWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSharedWallet request
	DeleteSharedWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSharedWallet request
	GetSharedWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSharedWalletInDelegation request  with any body
	PatchSharedWalletInDelegationWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSharedWalletInDelegation(ctx context.Context, walletId string, body PatchSharedWalletInDelegationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSharedWalletInPayment request  with any body
	PatchSharedWalletInPaymentWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSharedWalletInPayment(ctx context.Context, walletId string, body PatchSharedWalletInPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentSmashHealth request
	GetCurrentSmashHealth(ctx context.Context, params *GetCurrentSmashHealthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStakePools request
	ListStakePools(ctx context.Context, params *ListStakePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuitStakePool request  with any body
	QuitStakePoolWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QuitStakePool(ctx context.Context, walletId string, body QuitStakePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaintenanceActions request
	GetMaintenanceActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMaintenanceAction request  with any body
	PostMaintenanceActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMaintenanceAction(ctx context.Context, body PostMaintenanceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JoinStakePool request  with any body
	JoinStakePoolWithBody(ctx context.Context, stakePoolId string, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JoinStakePool(ctx context.Context, stakePoolId string, walletId string, body JoinStakePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWallets request
	ListWallets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWallet request  with any body
	PostWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWallet(ctx context.Context, body PostWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWallet request
	DeleteWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWallet request
	GetWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWallet request  with any body
	PutWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutWallet(ctx context.Context, walletId string, body PutWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddresses request
	ListAddresses(ctx context.Context, walletId string, params *ListAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssets request
	ListAssets(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetDefault request
	GetAssetDefault(ctx context.Context, walletId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAsset request
	GetAsset(ctx context.Context, walletId string, policyId string, assetName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectCoins request  with any body
	SelectCoinsWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectCoins(ctx context.Context, walletId string, body SelectCoinsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDelegationFee request
	GetDelegationFee(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAccountKey request  with any body
	PostAccountKeyWithBody(ctx context.Context, walletId string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAccountKey(ctx context.Context, walletId string, index string, body PostAccountKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletKey request
	GetWalletKey(ctx context.Context, walletId string, role string, index string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShelleyWalletMigrationInfo request
	GetShelleyWalletMigrationInfo(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateShelleyWallet request  with any body
	MigrateShelleyWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateShelleyWallet(ctx context.Context, walletId string, body MigrateShelleyWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWalletPassphrase request  with any body
	PutWalletPassphraseWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutWalletPassphrase(ctx context.Context, walletId string, body PutWalletPassphraseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransactionFee request  with any body
	PostTransactionFeeWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTransactionFee(ctx context.Context, walletId string, body PostTransactionFeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignMetadata request  with any body
	SignMetadataWithBody(ctx context.Context, walletId string, role string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignMetadata(ctx context.Context, walletId string, role string, index string, body SignMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUTxOsStatistics request
	GetUTxOsStatistics(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactions request
	ListTransactions(ctx context.Context, walletId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransaction request  with any body
	PostTransactionWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTransaction(ctx context.Context, walletId string, body PostTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAnyAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnyAddressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnyAddress(ctx context.Context, body PostAnyAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnyAddressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InspectAddress(ctx context.Context, addressId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInspectAddressRequest(c.Server, addressId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListByronWallets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListByronWalletsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronWalletRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronWallet(ctx context.Context, body PostByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronWalletRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteByronWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteByronWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutByronWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutByronWalletRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutByronWallet(ctx context.Context, walletId string, body PutByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutByronWalletRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListByronAddresses(ctx context.Context, walletId string, params *ListByronAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListByronAddressesRequest(c.Server, walletId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddressWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddressRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddress(ctx context.Context, walletId string, body CreateAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddressRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportAddressesWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportAddressesRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportAddresses(ctx context.Context, walletId string, body ImportAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportAddressesRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportAddress(ctx context.Context, walletId string, addressId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportAddressRequest(c.Server, walletId, addressId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListByronAssets(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListByronAssetsRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronAssetDefault(ctx context.Context, walletId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronAssetDefaultRequest(c.Server, walletId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronAsset(ctx context.Context, walletId string, policyId string, assetName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronAssetRequest(c.Server, walletId, policyId, assetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByronSelectCoinsWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByronSelectCoinsRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByronSelectCoins(ctx context.Context, walletId string, body ByronSelectCoinsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByronSelectCoinsRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronWalletMigrationInfo(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronWalletMigrationInfoRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateByronWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateByronWalletRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateByronWallet(ctx context.Context, walletId string, body MigrateByronWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateByronWalletRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutByronWalletPassphraseWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutByronWalletPassphraseRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutByronWalletPassphrase(ctx context.Context, walletId string, body PutByronWalletPassphraseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutByronWalletPassphraseRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronTransactionFeeWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronTransactionFeeRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronTransactionFee(ctx context.Context, walletId string, body PostByronTransactionFeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronTransactionFeeRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronUTxOsStatistics(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronUTxOsStatisticsRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListByronTransactions(ctx context.Context, walletId string, params *ListByronTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListByronTransactionsRequest(c.Server, walletId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronTransactionWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronTransactionRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostByronTransaction(ctx context.Context, walletId string, body PostByronTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostByronTransactionRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteByronTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteByronTransactionRequest(c.Server, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetByronTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByronTransactionRequest(c.Server, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkClock(ctx context.Context, params *GetNetworkClockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkClockRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkParameters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkParametersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExternalTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExternalTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSettings(ctx context.Context, body PutSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSharedWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSharedWalletRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSharedWallet(ctx context.Context, body PostSharedWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSharedWalletRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSharedWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSharedWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSharedWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSharedWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSharedWalletInDelegationWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSharedWalletInDelegationRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSharedWalletInDelegation(ctx context.Context, walletId string, body PatchSharedWalletInDelegationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSharedWalletInDelegationRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSharedWalletInPaymentWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSharedWalletInPaymentRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSharedWalletInPayment(ctx context.Context, walletId string, body PatchSharedWalletInPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSharedWalletInPaymentRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentSmashHealth(ctx context.Context, params *GetCurrentSmashHealthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentSmashHealthRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStakePools(ctx context.Context, params *ListStakePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStakePoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuitStakePoolWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuitStakePoolRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuitStakePool(ctx context.Context, walletId string, body QuitStakePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuitStakePoolRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaintenanceActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaintenanceActionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMaintenanceActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMaintenanceActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMaintenanceAction(ctx context.Context, body PostMaintenanceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMaintenanceActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JoinStakePoolWithBody(ctx context.Context, stakePoolId string, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJoinStakePoolRequestWithBody(c.Server, stakePoolId, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JoinStakePool(ctx context.Context, stakePoolId string, walletId string, body JoinStakePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJoinStakePoolRequest(c.Server, stakePoolId, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWallets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWalletsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWalletWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWalletRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWallet(ctx context.Context, body PostWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWalletRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWallet(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWalletRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWallet(ctx context.Context, walletId string, body PutWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWalletRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddresses(ctx context.Context, walletId string, params *ListAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddressesRequest(c.Server, walletId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssets(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetsRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetDefault(ctx context.Context, walletId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetDefaultRequest(c.Server, walletId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAsset(ctx context.Context, walletId string, policyId string, assetName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetRequest(c.Server, walletId, policyId, assetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectCoinsWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectCoinsRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectCoins(ctx context.Context, walletId string, body SelectCoinsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectCoinsRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDelegationFee(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDelegationFeeRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccountKeyWithBody(ctx context.Context, walletId string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountKeyRequestWithBody(c.Server, walletId, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccountKey(ctx context.Context, walletId string, index string, body PostAccountKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountKeyRequest(c.Server, walletId, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletKey(ctx context.Context, walletId string, role string, index string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletKeyRequest(c.Server, walletId, role, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShelleyWalletMigrationInfo(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShelleyWalletMigrationInfoRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateShelleyWalletWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateShelleyWalletRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateShelleyWallet(ctx context.Context, walletId string, body MigrateShelleyWalletJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateShelleyWalletRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWalletPassphraseWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWalletPassphraseRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWalletPassphrase(ctx context.Context, walletId string, body PutWalletPassphraseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWalletPassphraseRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionFeeWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionFeeRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionFee(ctx context.Context, walletId string, body PostTransactionFeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionFeeRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignMetadataWithBody(ctx context.Context, walletId string, role string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignMetadataRequestWithBody(c.Server, walletId, role, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignMetadata(ctx context.Context, walletId string, role string, index string, body SignMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignMetadataRequest(c.Server, walletId, role, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUTxOsStatistics(ctx context.Context, walletId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUTxOsStatisticsRequest(c.Server, walletId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactions(ctx context.Context, walletId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, walletId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionWithBody(ctx context.Context, walletId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionRequestWithBody(c.Server, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransaction(ctx context.Context, walletId string, body PostTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionRequest(c.Server, walletId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, walletId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAnyAddressRequest calls the generic PostAnyAddress builder with application/json body
func NewPostAnyAddressRequest(server string, body PostAnyAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnyAddressRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnyAddressRequestWithBody generates requests for PostAnyAddress with any type of body
func NewPostAnyAddressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addresses")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInspectAddressRequest generates requests for InspectAddress
func NewInspectAddressRequest(server string, addressId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "addressId", addressId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addresses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListByronWalletsRequest generates requests for ListByronWallets
func NewListByronWalletsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostByronWalletRequest calls the generic PostByronWallet builder with application/json body
func NewPostByronWalletRequest(server string, body PostByronWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostByronWalletRequestWithBody(server, "application/json", bodyReader)
}

// NewPostByronWalletRequestWithBody generates requests for PostByronWallet with any type of body
func NewPostByronWalletRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteByronWalletRequest generates requests for DeleteByronWallet
func NewDeleteByronWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetByronWalletRequest generates requests for GetByronWallet
func NewGetByronWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutByronWalletRequest calls the generic PutByronWallet builder with application/json body
func NewPutByronWalletRequest(server string, walletId string, body PutByronWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutByronWalletRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPutByronWalletRequestWithBody generates requests for PutByronWallet with any type of body
func NewPutByronWalletRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListByronAddressesRequest generates requests for ListByronAddresses
func NewListByronAddressesRequest(server string, walletId string, params *ListByronAddressesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.State != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "state", *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAddressRequest calls the generic CreateAddress builder with application/json body
func NewCreateAddressRequest(server string, walletId string, body CreateAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAddressRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewCreateAddressRequestWithBody generates requests for CreateAddress with any type of body
func NewCreateAddressRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportAddressesRequest calls the generic ImportAddresses builder with application/json body
func NewImportAddressesRequest(server string, walletId string, body ImportAddressesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportAddressesRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewImportAddressesRequestWithBody generates requests for ImportAddresses with any type of body
func NewImportAddressesRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportAddressRequest generates requests for ImportAddress
func NewImportAddressRequest(server string, walletId string, addressId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "addressId", addressId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/addresses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListByronAssetsRequest generates requests for ListByronAssets
func NewListByronAssetsRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetByronAssetDefaultRequest generates requests for GetByronAssetDefault
func NewGetByronAssetDefaultRequest(server string, walletId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "policyId", policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/assets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetByronAssetRequest generates requests for GetByronAsset
func NewGetByronAssetRequest(server string, walletId string, policyId string, assetName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "policyId", policyId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "assetName", assetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/assets/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewByronSelectCoinsRequest calls the generic ByronSelectCoins builder with application/json body
func NewByronSelectCoinsRequest(server string, walletId string, body ByronSelectCoinsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewByronSelectCoinsRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewByronSelectCoinsRequestWithBody generates requests for ByronSelectCoins with any type of body
func NewByronSelectCoinsRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/coin-selections/random", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetByronWalletMigrationInfoRequest generates requests for GetByronWalletMigrationInfo
func NewGetByronWalletMigrationInfoRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrateByronWalletRequest calls the generic MigrateByronWallet builder with application/json body
func NewMigrateByronWalletRequest(server string, walletId string, body MigrateByronWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateByronWalletRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewMigrateByronWalletRequestWithBody generates requests for MigrateByronWallet with any type of body
func NewMigrateByronWalletRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutByronWalletPassphraseRequest calls the generic PutByronWalletPassphrase builder with application/json body
func NewPutByronWalletPassphraseRequest(server string, walletId string, body PutByronWalletPassphraseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutByronWalletPassphraseRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPutByronWalletPassphraseRequestWithBody generates requests for PutByronWalletPassphrase with any type of body
func NewPutByronWalletPassphraseRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/passphrase", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostByronTransactionFeeRequest calls the generic PostByronTransactionFee builder with application/json body
func NewPostByronTransactionFeeRequest(server string, walletId string, body PostByronTransactionFeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostByronTransactionFeeRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPostByronTransactionFeeRequestWithBody generates requests for PostByronTransactionFee with any type of body
func NewPostByronTransactionFeeRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/payment-fees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetByronUTxOsStatisticsRequest generates requests for GetByronUTxOsStatistics
func NewGetByronUTxOsStatisticsRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/statistics/utxos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListByronTransactionsRequest generates requests for ListByronTransactions
func NewListByronTransactionsRequest(server string, walletId string, params *ListByronTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Start != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "start", *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.End != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "end", *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Order != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "order", *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostByronTransactionRequest calls the generic PostByronTransaction builder with application/json body
func NewPostByronTransactionRequest(server string, walletId string, body PostByronTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostByronTransactionRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPostByronTransactionRequestWithBody generates requests for PostByronTransaction with any type of body
func NewPostByronTransactionRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteByronTransactionRequest generates requests for DeleteByronTransaction
func NewDeleteByronTransactionRequest(server string, walletId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetByronTransactionRequest generates requests for GetByronTransaction
func NewGetByronTransactionRequest(server string, walletId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/byron-wallets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkClockRequest generates requests for GetNetworkClock
func NewGetNetworkClockRequest(server string, params *GetNetworkClockParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/clock")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.ForceNtpCheck != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "forceNtpCheck", *params.ForceNtpCheck); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkInformationRequest generates requests for GetNetworkInformation
func NewGetNetworkInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/information")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkParametersRequest generates requests for GetNetworkParameters
func NewGetNetworkParametersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/parameters")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExternalTransactionRequestWithBody generates requests for PostExternalTransaction with any type of body
func NewPostExternalTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proxy/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutSettingsRequest calls the generic PutSettings builder with application/json body
func NewPutSettingsRequest(server string, body PutSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPutSettingsRequestWithBody generates requests for PutSettings with any type of body
func NewPutSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSharedWalletRequest calls the generic PostSharedWallet builder with application/json body
func NewPostSharedWalletRequest(server string, body PostSharedWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSharedWalletRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSharedWalletRequestWithBody generates requests for PostSharedWallet with any type of body
func NewPostSharedWalletRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-wallets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSharedWalletRequest generates requests for DeleteSharedWallet
func NewDeleteSharedWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSharedWalletRequest generates requests for GetSharedWallet
func NewGetSharedWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSharedWalletInDelegationRequest calls the generic PatchSharedWalletInDelegation builder with application/json body
func NewPatchSharedWalletInDelegationRequest(server string, walletId string, body PatchSharedWalletInDelegationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSharedWalletInDelegationRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPatchSharedWalletInDelegationRequestWithBody generates requests for PatchSharedWalletInDelegation with any type of body
func NewPatchSharedWalletInDelegationRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-wallets/%s/delegation-script-template", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchSharedWalletInPaymentRequest calls the generic PatchSharedWalletInPayment builder with application/json body
func NewPatchSharedWalletInPaymentRequest(server string, walletId string, body PatchSharedWalletInPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSharedWalletInPaymentRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPatchSharedWalletInPaymentRequestWithBody generates requests for PatchSharedWalletInPayment with any type of body
func NewPatchSharedWalletInPaymentRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-wallets/%s/payment-script-template", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentSmashHealthRequest generates requests for GetCurrentSmashHealth
func NewGetCurrentSmashHealthRequest(server string, params *GetCurrentSmashHealthParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smash/health")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Url != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "url", *params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStakePoolsRequest generates requests for ListStakePools
func NewListStakePoolsRequest(server string, params *ListStakePoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stake-pools")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "stake", params.Stake); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQuitStakePoolRequest calls the generic QuitStakePool builder with application/json body
func NewQuitStakePoolRequest(server string, walletId string, body QuitStakePoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQuitStakePoolRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewQuitStakePoolRequestWithBody generates requests for QuitStakePool with any type of body
func NewQuitStakePoolRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stake-pools/*/wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMaintenanceActionsRequest generates requests for GetMaintenanceActions
func NewGetMaintenanceActionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stake-pools/maintenance-actions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMaintenanceActionRequest calls the generic PostMaintenanceAction builder with application/json body
func NewPostMaintenanceActionRequest(server string, body PostMaintenanceActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMaintenanceActionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostMaintenanceActionRequestWithBody generates requests for PostMaintenanceAction with any type of body
func NewPostMaintenanceActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stake-pools/maintenance-actions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJoinStakePoolRequest calls the generic JoinStakePool builder with application/json body
func NewJoinStakePoolRequest(server string, stakePoolId string, walletId string, body JoinStakePoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJoinStakePoolRequestWithBody(server, stakePoolId, walletId, "application/json", bodyReader)
}

// NewJoinStakePoolRequestWithBody generates requests for JoinStakePool with any type of body
func NewJoinStakePoolRequestWithBody(server string, stakePoolId string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "stakePoolId", stakePoolId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stake-pools/%s/wallets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWalletsRequest generates requests for ListWallets
func NewListWalletsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWalletRequest calls the generic PostWallet builder with application/json body
func NewPostWalletRequest(server string, body PostWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWalletRequestWithBody(server, "application/json", bodyReader)
}

// NewPostWalletRequestWithBody generates requests for PostWallet with any type of body
func NewPostWalletRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWalletRequest generates requests for DeleteWallet
func NewDeleteWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWalletRequest generates requests for GetWallet
func NewGetWalletRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWalletRequest calls the generic PutWallet builder with application/json body
func NewPutWalletRequest(server string, walletId string, body PutWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutWalletRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPutWalletRequestWithBody generates requests for PutWallet with any type of body
func NewPutWalletRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAddressesRequest generates requests for ListAddresses
func NewListAddressesRequest(server string, walletId string, params *ListAddressesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.State != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "state", *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAssetsRequest generates requests for ListAssets
func NewListAssetsRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetDefaultRequest generates requests for GetAssetDefault
func NewGetAssetDefaultRequest(server string, walletId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "policyId", policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/assets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetRequest generates requests for GetAsset
func NewGetAssetRequest(server string, walletId string, policyId string, assetName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "policyId", policyId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "assetName", assetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/assets/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSelectCoinsRequest calls the generic SelectCoins builder with application/json body
func NewSelectCoinsRequest(server string, walletId string, body SelectCoinsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectCoinsRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewSelectCoinsRequestWithBody generates requests for SelectCoins with any type of body
func NewSelectCoinsRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/coin-selections/random", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDelegationFeeRequest generates requests for GetDelegationFee
func NewGetDelegationFeeRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/delegation-fees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAccountKeyRequest calls the generic PostAccountKey builder with application/json body
func NewPostAccountKeyRequest(server string, walletId string, index string, body PostAccountKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAccountKeyRequestWithBody(server, walletId, index, "application/json", bodyReader)
}

// NewPostAccountKeyRequestWithBody generates requests for PostAccountKey with any type of body
func NewPostAccountKeyRequestWithBody(server string, walletId string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "index", index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWalletKeyRequest generates requests for GetWalletKey
func NewGetWalletKeyRequest(server string, walletId string, role string, index string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "role", role)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "index", index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/keys/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShelleyWalletMigrationInfoRequest generates requests for GetShelleyWalletMigrationInfo
func NewGetShelleyWalletMigrationInfoRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrateShelleyWalletRequest calls the generic MigrateShelleyWallet builder with application/json body
func NewMigrateShelleyWalletRequest(server string, walletId string, body MigrateShelleyWalletJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateShelleyWalletRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewMigrateShelleyWalletRequestWithBody generates requests for MigrateShelleyWallet with any type of body
func NewMigrateShelleyWalletRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutWalletPassphraseRequest calls the generic PutWalletPassphrase builder with application/json body
func NewPutWalletPassphraseRequest(server string, walletId string, body PutWalletPassphraseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutWalletPassphraseRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPutWalletPassphraseRequestWithBody generates requests for PutWalletPassphrase with any type of body
func NewPutWalletPassphraseRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/passphrase", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransactionFeeRequest calls the generic PostTransactionFee builder with application/json body
func NewPostTransactionFeeRequest(server string, walletId string, body PostTransactionFeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTransactionFeeRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPostTransactionFeeRequestWithBody generates requests for PostTransactionFee with any type of body
func NewPostTransactionFeeRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/payment-fees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSignMetadataRequest calls the generic SignMetadata builder with application/json body
func NewSignMetadataRequest(server string, walletId string, role string, index string, body SignMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignMetadataRequestWithBody(server, walletId, role, index, "application/json", bodyReader)
}

// NewSignMetadataRequestWithBody generates requests for SignMetadata with any type of body
func NewSignMetadataRequestWithBody(server string, walletId string, role string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "role", role)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "index", index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/signatures/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUTxOsStatisticsRequest generates requests for GetUTxOsStatistics
func NewGetUTxOsStatisticsRequest(server string, walletId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/statistics/utxos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, walletId string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Start != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "start", *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.End != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "end", *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.Order != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "order", *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	if params.MinWithdrawal != nil {
		if queryFrag, err := runtime.StyleParam("form", true, "minWithdrawal", *params.MinWithdrawal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTransactionRequest calls the generic PostTransaction builder with application/json body
func NewPostTransactionRequest(server string, walletId string, body PostTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTransactionRequestWithBody(server, walletId, "application/json", bodyReader)
}

// NewPostTransactionRequestWithBody generates requests for PostTransaction with any type of body
func NewPostTransactionRequestWithBody(server string, walletId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, walletId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, walletId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "walletId", walletId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "transactionId", transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAnyAddress request  with any body
	PostAnyAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostAnyAddressResponse, error)

	PostAnyAddressWithResponse(ctx context.Context, body PostAnyAddressJSONRequestBody) (*PostAnyAddressResponse, error)

	// InspectAddress request
	InspectAddressWithResponse(ctx context.Context, addressId string) (*InspectAddressResponse, error)

	// ListByronWallets request
	ListByronWalletsWithResponse(ctx context.Context) (*ListByronWalletsResponse, error)

	// PostByronWallet request  with any body
	PostByronWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostByronWalletResponse, error)

	PostByronWalletWithResponse(ctx context.Context, body PostByronWalletJSONRequestBody) (*PostByronWalletResponse, error)

	// DeleteByronWallet request
	DeleteByronWalletWithResponse(ctx context.Context, walletId string) (*DeleteByronWalletResponse, error)

	// GetByronWallet request
	GetByronWalletWithResponse(ctx context.Context, walletId string) (*GetByronWalletResponse, error)

	// PutByronWallet request  with any body
	PutByronWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutByronWalletResponse, error)

	PutByronWalletWithResponse(ctx context.Context, walletId string, body PutByronWalletJSONRequestBody) (*PutByronWalletResponse, error)

	// ListByronAddresses request
	ListByronAddressesWithResponse(ctx context.Context, walletId string, params *ListByronAddressesParams) (*ListByronAddressesResponse, error)

	// CreateAddress request  with any body
	CreateAddressWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*CreateAddressResponse, error)

	CreateAddressWithResponse(ctx context.Context, walletId string, body CreateAddressJSONRequestBody) (*CreateAddressResponse, error)

	// ImportAddresses request  with any body
	ImportAddressesWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*ImportAddressesResponse, error)

	ImportAddressesWithResponse(ctx context.Context, walletId string, body ImportAddressesJSONRequestBody) (*ImportAddressesResponse, error)

	// ImportAddress request
	ImportAddressWithResponse(ctx context.Context, walletId string, addressId string) (*ImportAddressResponse, error)

	// ListByronAssets request
	ListByronAssetsWithResponse(ctx context.Context, walletId string) (*ListByronAssetsResponse, error)

	// GetByronAssetDefault request
	GetByronAssetDefaultWithResponse(ctx context.Context, walletId string, policyId string) (*GetByronAssetDefaultResponse, error)

	// GetByronAsset request
	GetByronAssetWithResponse(ctx context.Context, walletId string, policyId string, assetName string) (*GetByronAssetResponse, error)

	// ByronSelectCoins request  with any body
	ByronSelectCoinsWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*ByronSelectCoinsResponse, error)

	ByronSelectCoinsWithResponse(ctx context.Context, walletId string, body ByronSelectCoinsJSONRequestBody) (*ByronSelectCoinsResponse, error)

	// GetByronWalletMigrationInfo request
	GetByronWalletMigrationInfoWithResponse(ctx context.Context, walletId string) (*GetByronWalletMigrationInfoResponse, error)

	// MigrateByronWallet request  with any body
	MigrateByronWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*MigrateByronWalletResponse, error)

	MigrateByronWalletWithResponse(ctx context.Context, walletId string, body MigrateByronWalletJSONRequestBody) (*MigrateByronWalletResponse, error)

	// PutByronWalletPassphrase request  with any body
	PutByronWalletPassphraseWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutByronWalletPassphraseResponse, error)

	PutByronWalletPassphraseWithResponse(ctx context.Context, walletId string, body PutByronWalletPassphraseJSONRequestBody) (*PutByronWalletPassphraseResponse, error)

	// PostByronTransactionFee request  with any body
	PostByronTransactionFeeWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostByronTransactionFeeResponse, error)

	PostByronTransactionFeeWithResponse(ctx context.Context, walletId string, body PostByronTransactionFeeJSONRequestBody) (*PostByronTransactionFeeResponse, error)

	// GetByronUTxOsStatistics request
	GetByronUTxOsStatisticsWithResponse(ctx context.Context, walletId string) (*GetByronUTxOsStatisticsResponse, error)

	// ListByronTransactions request
	ListByronTransactionsWithResponse(ctx context.Context, walletId string, params *ListByronTransactionsParams) (*ListByronTransactionsResponse, error)

	// PostByronTransaction request  with any body
	PostByronTransactionWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostByronTransactionResponse, error)

	PostByronTransactionWithResponse(ctx context.Context, walletId string, body PostByronTransactionJSONRequestBody) (*PostByronTransactionResponse, error)

	// DeleteByronTransaction request
	DeleteByronTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*DeleteByronTransactionResponse, error)

	// GetByronTransaction request
	GetByronTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*GetByronTransactionResponse, error)

	// GetNetworkClock request
	GetNetworkClockWithResponse(ctx context.Context, params *GetNetworkClockParams) (*GetNetworkClockResponse, error)

	// GetNetworkInformation request
	GetNetworkInformationWithResponse(ctx context.Context) (*GetNetworkInformationResponse, error)

	// GetNetworkParameters request
	GetNetworkParametersWithResponse(ctx context.Context) (*GetNetworkParametersResponse, error)

	// PostExternalTransaction request  with any body
	PostExternalTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostExternalTransactionResponse, error)

	// GetSettings request
	GetSettingsWithResponse(ctx context.Context) (*GetSettingsResponse, error)

	// PutSettings request  with any body
	PutSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PutSettingsResponse, error)

	PutSettingsWithResponse(ctx context.Context, body PutSettingsJSONRequestBody) (*PutSettingsResponse, error)

	// PostSharedWallet request  with any body
	PostSharedWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostSharedWalletResponse, error)

	PostSharedWalletWithResponse(ctx context.Context, body PostSharedWalletJSONRequestBody) (*PostSharedWalletResponse, error)

	// DeleteSharedWallet request
	DeleteSharedWalletWithResponse(ctx context.Context, walletId string) (*DeleteSharedWalletResponse, error)

	// GetSharedWallet request
	GetSharedWalletWithResponse(ctx context.Context, walletId string) (*GetSharedWalletResponse, error)

	// PatchSharedWalletInDelegation request  with any body
	PatchSharedWalletInDelegationWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PatchSharedWalletInDelegationResponse, error)

	PatchSharedWalletInDelegationWithResponse(ctx context.Context, walletId string, body PatchSharedWalletInDelegationJSONRequestBody) (*PatchSharedWalletInDelegationResponse, error)

	// PatchSharedWalletInPayment request  with any body
	PatchSharedWalletInPaymentWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PatchSharedWalletInPaymentResponse, error)

	PatchSharedWalletInPaymentWithResponse(ctx context.Context, walletId string, body PatchSharedWalletInPaymentJSONRequestBody) (*PatchSharedWalletInPaymentResponse, error)

	// GetCurrentSmashHealth request
	GetCurrentSmashHealthWithResponse(ctx context.Context, params *GetCurrentSmashHealthParams) (*GetCurrentSmashHealthResponse, error)

	// ListStakePools request
	ListStakePoolsWithResponse(ctx context.Context, params *ListStakePoolsParams) (*ListStakePoolsResponse, error)

	// QuitStakePool request  with any body
	QuitStakePoolWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*QuitStakePoolResponse, error)

	QuitStakePoolWithResponse(ctx context.Context, walletId string, body QuitStakePoolJSONRequestBody) (*QuitStakePoolResponse, error)

	// GetMaintenanceActions request
	GetMaintenanceActionsWithResponse(ctx context.Context) (*GetMaintenanceActionsResponse, error)

	// PostMaintenanceAction request  with any body
	PostMaintenanceActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostMaintenanceActionResponse, error)

	PostMaintenanceActionWithResponse(ctx context.Context, body PostMaintenanceActionJSONRequestBody) (*PostMaintenanceActionResponse, error)

	// JoinStakePool request  with any body
	JoinStakePoolWithBodyWithResponse(ctx context.Context, stakePoolId string, walletId string, contentType string, body io.Reader) (*JoinStakePoolResponse, error)

	JoinStakePoolWithResponse(ctx context.Context, stakePoolId string, walletId string, body JoinStakePoolJSONRequestBody) (*JoinStakePoolResponse, error)

	// ListWallets request
	ListWalletsWithResponse(ctx context.Context) (*ListWalletsResponse, error)

	// PostWallet request  with any body
	PostWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostWalletResponse, error)

	PostWalletWithResponse(ctx context.Context, body PostWalletJSONRequestBody) (*PostWalletResponse, error)

	// DeleteWallet request
	DeleteWalletWithResponse(ctx context.Context, walletId string) (*DeleteWalletResponse, error)

	// GetWallet request
	GetWalletWithResponse(ctx context.Context, walletId string) (*GetWalletResponse, error)

	// PutWallet request  with any body
	PutWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutWalletResponse, error)

	PutWalletWithResponse(ctx context.Context, walletId string, body PutWalletJSONRequestBody) (*PutWalletResponse, error)

	// ListAddresses request
	ListAddressesWithResponse(ctx context.Context, walletId string, params *ListAddressesParams) (*ListAddressesResponse, error)

	// ListAssets request
	ListAssetsWithResponse(ctx context.Context, walletId string) (*ListAssetsResponse, error)

	// GetAssetDefault request
	GetAssetDefaultWithResponse(ctx context.Context, walletId string, policyId string) (*GetAssetDefaultResponse, error)

	// GetAsset request
	GetAssetWithResponse(ctx context.Context, walletId string, policyId string, assetName string) (*GetAssetResponse, error)

	// SelectCoins request  with any body
	SelectCoinsWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*SelectCoinsResponse, error)

	SelectCoinsWithResponse(ctx context.Context, walletId string, body SelectCoinsJSONRequestBody) (*SelectCoinsResponse, error)

	// GetDelegationFee request
	GetDelegationFeeWithResponse(ctx context.Context, walletId string) (*GetDelegationFeeResponse, error)

	// PostAccountKey request  with any body
	PostAccountKeyWithBodyWithResponse(ctx context.Context, walletId string, index string, contentType string, body io.Reader) (*PostAccountKeyResponse, error)

	PostAccountKeyWithResponse(ctx context.Context, walletId string, index string, body PostAccountKeyJSONRequestBody) (*PostAccountKeyResponse, error)

	// GetWalletKey request
	GetWalletKeyWithResponse(ctx context.Context, walletId string, role string, index string) (*GetWalletKeyResponse, error)

	// GetShelleyWalletMigrationInfo request
	GetShelleyWalletMigrationInfoWithResponse(ctx context.Context, walletId string) (*GetShelleyWalletMigrationInfoResponse, error)

	// MigrateShelleyWallet request  with any body
	MigrateShelleyWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*MigrateShelleyWalletResponse, error)

	MigrateShelleyWalletWithResponse(ctx context.Context, walletId string, body MigrateShelleyWalletJSONRequestBody) (*MigrateShelleyWalletResponse, error)

	// PutWalletPassphrase request  with any body
	PutWalletPassphraseWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutWalletPassphraseResponse, error)

	PutWalletPassphraseWithResponse(ctx context.Context, walletId string, body PutWalletPassphraseJSONRequestBody) (*PutWalletPassphraseResponse, error)

	// PostTransactionFee request  with any body
	PostTransactionFeeWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostTransactionFeeResponse, error)

	PostTransactionFeeWithResponse(ctx context.Context, walletId string, body PostTransactionFeeJSONRequestBody) (*PostTransactionFeeResponse, error)

	// SignMetadata request  with any body
	SignMetadataWithBodyWithResponse(ctx context.Context, walletId string, role string, index string, contentType string, body io.Reader) (*SignMetadataResponse, error)

	SignMetadataWithResponse(ctx context.Context, walletId string, role string, index string, body SignMetadataJSONRequestBody) (*SignMetadataResponse, error)

	// GetUTxOsStatistics request
	GetUTxOsStatisticsWithResponse(ctx context.Context, walletId string) (*GetUTxOsStatisticsResponse, error)

	// ListTransactions request
	ListTransactionsWithResponse(ctx context.Context, walletId string, params *ListTransactionsParams) (*ListTransactionsResponse, error)

	// PostTransaction request  with any body
	PostTransactionWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostTransactionResponse, error)

	PostTransactionWithResponse(ctx context.Context, walletId string, body PostTransactionJSONRequestBody) (*PostTransactionResponse, error)

	// DeleteTransaction request
	DeleteTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*DeleteTransactionResponse, error)

	// GetTransaction request
	GetTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*GetTransactionResponse, error)
}

type PostAnyAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A Shelley address representing either enterprise, reward account or delegating address
		Address string `json:"address"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAnyAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnyAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InspectAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Only for 'Icarus' and 'Byron' styles.
		AddressRoot  *string `json:"address_root,omitempty"`
		AddressStyle string  `json:"address_style"`

		// Only for 'Byron' style.
		DerivationPath *string `json:"derivation_path,omitempty"`

		// Can be null for 'Icarus' and 'Byron' styles.
		NetworkTag *int `json:"network_tag,omitempty"`
		Pointer    *struct {
			OutputIndex      int `json:"output_index"`
			SlotNum          int `json:"slot_num"`
			TransactionIndex int `json:"transaction_index"`
		} `json:"pointer,omitempty"`
		ScriptHash        *string `json:"script_hash,omitempty"`
		ScriptHashBech32  *string `json:"script_hash_bech32,omitempty"`
		SpendingKeyBech32 *string `json:"spending_key_bech32,omitempty"`
		SpendingKeyHash   *string `json:"spending_key_hash,omitempty"`
		StakeKeyBech32    *string `json:"stake_key_bech32,omitempty"`
		StakeKeyHash      *string `json:"stake_key_hash,omitempty"`
		StakeReference    string  `json:"stake_reference"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r InspectAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InspectAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListByronWalletsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Byron wallet's current balance(s)
		Balance struct {

			// Available balance (funds that can be spent)
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// Total balance (available balance plus pending change)
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Mechanism used for discovering addresses.
		Discovery string `json:"discovery"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListByronWalletsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListByronWalletsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostByronWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Byron wallet's current balance(s)
		Balance struct {

			// Available balance (funds that can be spent)
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// Total balance (available balance plus pending change)
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Mechanism used for discovering addresses.
		Discovery string `json:"discovery"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON409 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
	JSON415 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostByronWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostByronWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteByronWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteByronWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByronWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Byron wallet's current balance(s)
		Balance struct {

			// Available balance (funds that can be spent)
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// Total balance (available balance plus pending change)
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Mechanism used for discovering addresses.
		Discovery string `json:"discovery"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON404 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutByronWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Number of consecutive unused addresses allowed.
		//
		// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
		// your wallet in a different software which is strictly following BIP-44.
		//
		// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
		AddressPoolGap int `json:"address_pool_gap"`

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Wallet current Ada balance(s).
		Balance struct {

			// Available Ada UTxO balance (funds that can be spent without condition).
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// The Ada balance of the reward account for this wallet.
			Reward struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"reward"`

			// Total Ada balance (available balance plus pending change and reward balance).
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Delegation settings
		Delegation struct {

			// Currently active delegation status.
			Active struct {
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"active"`
			Next []struct {
				ChangesAt struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"changes_at"`
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"next"`
		} `json:"delegation"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PutByronWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutByronWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListByronAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// A path for deriving a child key from a parent key.
		DerivationPath []string `json:"derivation_path"`
		Id             string   `json:"id"`
		State          string   `json:"state"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListByronAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListByronAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// A path for deriving a child key from a parent key.
		DerivationPath []string `json:"derivation_path"`
		Id             string   `json:"id"`
		State          string   `json:"state"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ImportAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ImportAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListByronAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListByronAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListByronAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronAssetDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// Occurs when requesting information about an asset which is not
		// involved in any transaction related to the wallet.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronAssetDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronAssetDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// Occurs when requesting information about an asset which is not
		// involved in any transaction related to the wallet.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByronSelectCoinsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Certificates *[]struct {
			CertificateType string `json:"certificate_type"`

			// A unique identifier for the pool.
			Pool              *string  `json:"pool,omitempty"`
			RewardAccountPath []string `json:"reward_account_path"`
		} `json:"certificates,omitempty"`

		// A list of transaction change outputs.
		Change []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
		} `json:"change"`

		// A list of deposits associated with a transaction.
		Deposits *[]struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposits,omitempty"`

		// A list of transaction inputs
		Inputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
		Metadata *string `json:"metadata,omitempty"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A list of withdrawals from stake addresses.
		Withdrawals *[]struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
			StakeAddress   string   `json:"stake_address"`
		} `json:"withdrawals,omitempty"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ByronSelectCoinsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByronSelectCoinsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronWalletMigrationInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Leftovers dust coins which won't be migrated nor spent as fees.
		Leftovers struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"leftovers"`

		// Total amount which will be paid as fees for the migration.
		MigrationCost struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"migration_cost"`
	}
	JSON403 *struct {
		Code string `json:"code"`

		// May occur when trying to migrate a wallet that is empty or full of dust.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronWalletMigrationInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronWalletMigrationInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateByronWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r MigrateByronWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateByronWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutByronWalletPassphraseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PutByronWalletPassphraseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutByronWalletPassphraseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostByronTransactionFeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMax struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_max"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMin struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_min"`

		// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
		//
		//   - (a) Some updatable protocol parameters fixed by the network.
		//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
		//
		// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
		// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
		// when calculating fee for delegation), this list is empty.
		//
		// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
		// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
		//
		// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
		// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
		MinimumCoins []struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"minimum_coins"`
	}
	JSON400 *interface{}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostByronTransactionFeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostByronTransactionFeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronUTxOsStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Distribution Distribution `json:"distribution"`
		Scale        string       `json:"scale"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Total struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"total"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronUTxOsStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronUTxOsStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListByronTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListByronTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListByronTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostByronTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *interface{}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostByronTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostByronTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteByronTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *struct {
		Code string `json:"code"`

		// Occurs when attempting to delete a transaction which is neither pending nor expired.
		Message string `json:"message"`
	}
	JSON404 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteByronTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByronTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByronTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON404 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByronTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByronTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkClockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == available
		// </span><br/>
		// Drift offset of the local clock.
		Offset *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"offset,omitempty"`
		Status string `json:"status"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNetworkClockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkClockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The time slot corresponding the network tip.
		NetworkTip *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"network_tip,omitempty"`
		NextEpoch *struct {

			// An epoch is a time period which is divided into slots.
			EpochNumber    int    `json:"epoch_number"`
			EpochStartTime string `json:"epoch_start_time"`
		} `json:"next_epoch,omitempty"`
		NodeEra string `json:"node_era"`

		// Underlying node's tip
		NodeTip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"node_tip"`

		// Estimated synchronization progress of the node with the underlying network. Note that this may
		// change quite arbitrarily as the node may switch to shorter or longer chain forks.
		SyncProgress struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"sync_progress"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNetworkInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkParametersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ActiveSlotCoefficient struct {
			Quantity float32 `json:"quantity"`
			Unit     string  `json:"unit"`
		} `json:"active_slot_coefficient"`
		BlockchainStartTime   string `json:"blockchain_start_time"`
		DecentralizationLevel struct {
			Quantity float32 `json:"quantity"`
			Unit     string  `json:"unit"`
		} `json:"decentralization_level"`
		DesiredPoolNumber int `json:"desired_pool_number"`
		EpochLength       struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"epoch_length"`

		//
		// If and when each era started or will start.
		//
		// The object is keyed by era names. The values either describe the epoch boundary
		// when the era starts (can be in the future or in the past), or are null if not yet
		// confirmed on-chain.
		//
		// If you need to know the current era, see the `node_era` field of
		// `GET /network/information`.
		//
		// > Due to complications with our current tooling, we cannot mark the era names
		// > as required, but the keys are in fact always present.
		Eras struct {
			Allegra *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"allegra"`
			Byron *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"byron"`
			Mary *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"mary"`
			Shelley *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"shelley"`
		} `json:"eras"`

		// The hash of genesis block
		GenesisBlockHash string `json:"genesis_block_hash"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		MinimumUtxoValue struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"minimum_utxo_value"`
		SecurityParameter struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"security_parameter"`
		SlotLength struct {
			Quantity float32 `json:"quantity"`
			Unit     string  `json:"unit"`
		} `json:"slot_length"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNetworkParametersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkParametersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExternalTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A unique identifier for this transaction
		Id string `json:"id"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostExternalTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExternalTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Pool metadata source. This sets the metadata fetching strategy.
		//
		// Possible values are
		//   * none -> no fetching
		//   * direct -> direct fetching
		//   * uri -> use SMASH server
		PoolMetadataSource string `json:"pool_metadata_source"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PutSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSharedWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *interface{}
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON409 *struct {
		Code string `json:"code"`

		// May occur when a otherwise valid request would yield a wallet that already exists.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostSharedWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSharedWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSharedWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSharedWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSharedWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSharedWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSharedWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSharedWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSharedWalletInDelegationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchSharedWalletInDelegationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSharedWalletInDelegationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSharedWalletInPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchSharedWalletInPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSharedWalletInPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentSmashHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Health string `json:"health"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCurrentSmashHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentSmashHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStakePoolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// Estimated cost set by the pool operator when registering his pool.
		// This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
		//
		// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
		Cost struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"cost"`

		// Various flags applicable to stake pools. Possible flags:
		//
		// | flag     | description                                                                                                      |
		// | ---      | ---                                                                                                              |
		// | delisted | The pool is marked as delisted on a configured SMASH server; metadata for this pool have therefore been dropped. |
		Flags []string `json:"flags"`

		// A unique identifier for the pool.
		Id string `json:"id"`

		// Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
		//
		// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
		Margin struct {
			Quantity float32 `json:"quantity"`
			Unit     string  `json:"unit"`
		} `json:"margin"`

		// Information about the stake pool.
		Metadata *struct {
			Description *string `json:"description,omitempty"`
			Homepage    string  `json:"homepage"`
			Name        string  `json:"name"`
			Ticker      string  `json:"ticker"`
		} `json:"metadata,omitempty"`
		Metrics struct {

			// The rewards the wallet can expect to receive at the end of an epoch, in the long term, if delegating to
			// this pool.
			//
			// For more details, see the
			// [Design Specification for Delegation and Incentives in Cardano](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec)
			// document.
			NonMyopicMemberRewards struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"non_myopic_member_rewards"`

			// Number of blocks produced by a given stake pool in its lifetime.
			ProducedBlocks struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"produced_blocks"`

			// The live pool stake relative to the *total* stake.
			//
			// For more details, see the section "Relative Stake: Active vs Total" in
			// [Design Specification for Delegation and Incentives in Cardano](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec).
			RelativeStake struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"relative_stake"`

			// Saturation-level of the pool based on the desired number of pools aimed by the network.
			// A value above `1` indicates that the pool is saturated.
			//
			// The `non_myopic_member_rewards` take oversaturation into account, as specified by the [specs](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec).
			//
			// The saturation is based on the live `relative_stake`. The saturation at the end of epoch e,
			// will affect the rewards paid out at the end of epoch e+3.
			Saturation float32 `json:"saturation"`
		} `json:"metrics"`

		// Minimal stake amount that a stake pool is willing to honor.
		//
		// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
		Pledge struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"pledge"`

		// The epoch in which a stake pool retires.
		//
		// May be omitted if the wallet hasn't yet found a retirement certificate
		// for this stake pool.
		Retirement *struct {

			// An epoch is a time period which is divided into slots.
			EpochNumber    int    `json:"epoch_number"`
			EpochStartTime string `json:"epoch_start_time"`
		} `json:"retirement,omitempty"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when an endpoint requires the presence of a query parameter that is missing.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListStakePoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStakePoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuitStakePoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r QuitStakePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuitStakePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaintenanceActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Gives an indication if metadata GC checking for delisted pools
		// has run and if so, when.
		//
		// Possible values are:
		//   - not_applicable -> we're currently not querying a SMASH server for metadata
		//   - not_started -> the GC hasn't started yet, try again in a short while
		//   - restarting -> the GC thread is currently restarting, try again in short while
		//   - has_run -> the GC has run successfully
		//
		// When 'status' is 'restarting' or 'has_run' then the field 'last_run'
		// is set to the last GC time in UTC.
		GcStakePools struct {
			LastRun *string `json:"last_run,omitempty"`
			Status  string  `json:"status"`
		} `json:"gc_stake_pools"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMaintenanceActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaintenanceActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMaintenanceActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostMaintenanceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMaintenanceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JoinStakePoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r JoinStakePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JoinStakePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWalletsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// Number of consecutive unused addresses allowed.
		//
		// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
		// your wallet in a different software which is strictly following BIP-44.
		//
		// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
		AddressPoolGap int `json:"address_pool_gap"`

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Wallet current Ada balance(s).
		Balance struct {

			// Available Ada UTxO balance (funds that can be spent without condition).
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// The Ada balance of the reward account for this wallet.
			Reward struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"reward"`

			// Total Ada balance (available balance plus pending change and reward balance).
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Delegation settings
		Delegation struct {

			// Currently active delegation status.
			Active struct {
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"active"`
			Next []struct {
				ChangesAt struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"changes_at"`
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"next"`
		} `json:"delegation"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWalletsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWalletsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// Number of consecutive unused addresses allowed.
		//
		// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
		// your wallet in a different software which is strictly following BIP-44.
		//
		// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
		AddressPoolGap int `json:"address_pool_gap"`

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Wallet current Ada balance(s).
		Balance struct {

			// Available Ada UTxO balance (funds that can be spent without condition).
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// The Ada balance of the reward account for this wallet.
			Reward struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"reward"`

			// Total Ada balance (available balance plus pending change and reward balance).
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Delegation settings
		Delegation struct {

			// Currently active delegation status.
			Active struct {
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"active"`
			Next []struct {
				ChangesAt struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"changes_at"`
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"next"`
		} `json:"delegation"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON409 *struct {
		Code string `json:"code"`

		// May occur when a otherwise valid request would yield a wallet that already exists.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Number of consecutive unused addresses allowed.
		//
		// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
		// your wallet in a different software which is strictly following BIP-44.
		//
		// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
		AddressPoolGap int `json:"address_pool_gap"`

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Wallet current Ada balance(s).
		Balance struct {

			// Available Ada UTxO balance (funds that can be spent without condition).
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// The Ada balance of the reward account for this wallet.
			Reward struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"reward"`

			// Total Ada balance (available balance plus pending change and reward balance).
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Delegation settings
		Delegation struct {

			// Currently active delegation status.
			Active struct {
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"active"`
			Next []struct {
				ChangesAt struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"changes_at"`
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"next"`
		} `json:"delegation"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Number of consecutive unused addresses allowed.
		//
		// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
		// your wallet in a different software which is strictly following BIP-44.
		//
		// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
		AddressPoolGap int `json:"address_pool_gap"`

		// Current non-Ada asset holdings of the wallet.
		//
		// The amount of assets available to spend may be less than the total
		// unspent assets due to transaction change amounts which are yet to
		// be fully confirmed (pending).
		Assets struct {

			// Available UTxO asset balances (funds that can be spent without
			// condition).
			Available []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"available"`

			// Total asset balances (available balances plus pending change balances).
			Total []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"total"`
		} `json:"assets"`

		// Wallet current Ada balance(s).
		Balance struct {

			// Available Ada UTxO balance (funds that can be spent without condition).
			Available struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"available"`

			// The Ada balance of the reward account for this wallet.
			Reward struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"reward"`

			// Total Ada balance (available balance plus pending change and reward balance).
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		} `json:"balance"`

		// Delegation settings
		Delegation struct {

			// Currently active delegation status.
			Active struct {
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"active"`
			Next []struct {
				ChangesAt struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"changes_at"`
				Status string `json:"status"`

				// A unique Stake-Pool identifier (present only if status = `delegating`)
				Target *string `json:"target,omitempty"`
			} `json:"next"`
		} `json:"delegation"`

		// A unique identifier for the wallet
		Id   string `json:"id"`
		Name string `json:"name"`

		// Information about the wallet's passphrase
		Passphrase *struct {
			LastUpdatedAt string `json:"last_updated_at"`
		} `json:"passphrase,omitempty"`

		// Whether a wallet is ready to use or still syncing
		State struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == syncing
			// </span><br/>
			Progress *struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"progress,omitempty"`
			Status string `json:"status"`
		} `json:"state"`

		// A reference to a particular time slot, and the block height at that point.
		Tip struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"tip"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PutWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// A path for deriving a child key from a parent key.
		DerivationPath []string `json:"derivation_path"`
		Id             string   `json:"id"`
		State          string   `json:"state"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// Occurs when requesting information about an asset which is not
		// involved in any transaction related to the wallet.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssetDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The asset on-chain type which acts as a sub-identifier within a
		// policy. Although we call it "asset name", the value needn't be
		// text, and it could even be empty.
		//
		// For policies with a single fungible asset item, asset name is
		// typically an empty string.
		//
		// This value can be up to 32 bytes of arbitrary data (which is 64
		// hexadecimal digits).
		AssetName string `json:"asset_name"`

		// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
		// to allow for an easier human comparison of assets. Note that it is generally
		// **not okay** to use this fingerprint as a unique identifier for it is not collision
		// resistant. Yet within the context of a single wallet, it makes for a (rather)
		// short user-facing comparison mean.
		Fingerprint string `json:"fingerprint"`

		// In the Mary era of Cardano, UTxO may contain native assets. These
		// assets are represented on-chain by opaque identifiers which are
		// meaningless to end-users. Therefore, user-facing metadata
		// regarding each token must be stored off-chain, in a metadata
		// registry.
		//
		// Token creators may publish metadata into the registry and client
		// applications can consume these metadata for display to end
		// users. This will work in a similar way to how it is done for stake
		// pool metadata.
		Metadata *struct {

			// A human-readable description for the asset. Good for display in
			// user interfaces.
			Description string `json:"description"`

			// A base64-encoded `image/png` for displaying the asset. The end image can be expected
			// to be smaller than 64KB.
			Logo *string `json:"logo,omitempty"`

			// A human-readable name for the asset, intended for display in user
			// interfaces.
			Name string `json:"name"`

			// An optional human-readable very short name or acronym for the
			// asset, intended for display in user interfaces. If `ticker` is not
			// present, then `name` will be used, but it might be truncated to
			// fit within the available space.
			Ticker *string `json:"ticker,omitempty"`

			// Defines a larger unit for the asset, in the same way Ada is the
			// larger unit of Lovelace.
			Unit *struct {

				// The number of digits after the decimal point.
				Decimals int `json:"decimals"`

				// The human-readable name for the larger unit of the asset. Used
				// for display in user interfaces.
				Name string `json:"name"`
			} `json:"unit,omitempty"`

			// A URL to the policy's owner(s) or the entity website in charge of the asset.
			Url *string `json:"url,omitempty"`
		} `json:"metadata,omitempty"`

		// A unique identifier of the asset's monetary policy. The policy
		// controls how assets of this kind are created and destroyed.
		//
		// The contents are the blake2b-224 hash of the monetary policy
		// script, encoded in hexadecimal.
		PolicyId string `json:"policy_id"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// Occurs when requesting information about an asset which is not
		// involved in any transaction related to the wallet.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectCoinsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Certificates *[]struct {
			CertificateType string `json:"certificate_type"`

			// A unique identifier for the pool.
			Pool              *string  `json:"pool,omitempty"`
			RewardAccountPath []string `json:"reward_account_path"`
		} `json:"certificates,omitempty"`

		// A list of transaction change outputs.
		Change []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
		} `json:"change"`

		// A list of deposits associated with a transaction.
		Deposits *[]struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposits,omitempty"`

		// A list of transaction inputs
		Inputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
		Metadata *string `json:"metadata,omitempty"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A list of withdrawals from stake addresses.
		Withdrawals *[]struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
			StakeAddress   string   `json:"stake_address"`
		} `json:"withdrawals,omitempty"`
	}
	JSON400 *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r SelectCoinsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectCoinsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDelegationFeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMax struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_max"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMin struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_min"`

		// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
		//
		//   - (a) Some updatable protocol parameters fixed by the network.
		//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
		//
		// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
		// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
		// when calculating fee for delegation), this list is empty.
		//
		// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
		// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
		//
		// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
		// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
		MinimumCoins []struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"minimum_coins"`
	}
	JSON403 *struct {
		Code string `json:"code"`

		// May occur when a transaction can't be balanced for fees.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDelegationFeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDelegationFeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAccountKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAccountKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAccountKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON404 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWalletKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShelleyWalletMigrationInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Leftovers dust coins which won't be migrated nor spent as fees.
		Leftovers struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"leftovers"`

		// Total amount which will be paid as fees for the migration.
		MigrationCost struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"migration_cost"`
	}
	JSON403 *struct {
		Code string `json:"code"`

		// May occur when trying to migrate a wallet that is empty or full of dust.
		Message string `json:"message"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetShelleyWalletMigrationInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShelleyWalletMigrationInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateShelleyWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r MigrateShelleyWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateShelleyWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWalletPassphraseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PutWalletPassphraseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWalletPassphraseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransactionFeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMax struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_max"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		EstimatedMin struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"estimated_min"`

		// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
		//
		//   - (a) Some updatable protocol parameters fixed by the network.
		//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
		//
		// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
		// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
		// when calculating fee for delegation), this list is empty.
		//
		// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
		// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
		//
		// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
		// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
		MinimumCoins []struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"minimum_coins"`
	}
	JSON400 *interface{}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostTransactionFeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransactionFeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code string `json:"code"`

		// May occur when a request is not well-formed; that is, it fails to parse
		// successfully. This could be the case when some required parameters
		// are missing or, when malformed values are provided.
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {

		// A specific error code for this error, more precise than HTTP ones.
		Code string `json:"code"`

		// A descriptive error message.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r SignMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUTxOsStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Distribution Distribution `json:"distribution"`
		Scale        string       `json:"scale"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Total struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"total"`
	}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUTxOsStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUTxOsStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON400 *interface{}
	JSON403 *interface{}
	JSON404 *struct {
		Code string `json:"code"`

		// May occur when a given walletId does not match with any known
		// wallets (because it has been deleted, or has never existed).
		Message string `json:"message"`
	}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
	JSON415 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Content-Type' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r PostTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *struct {
		Code string `json:"code"`

		// Occurs when attempting to delete a transaction which is neither pending nor expired.
		Message string `json:"message"`
	}
	JSON404 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// An amount of Ada spent or received, from the perspective of the wallet.
		//
		// That is, for outgoing transaction, it represents the amount of Ada consumed
		// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
		// which do not belong to the wallet.
		//
		// For incoming transaction, it represents the total amount of Ada received to
		// addresses that belong to the wallet.
		Amount struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"amount"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Deposit struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"deposit"`

		// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
		// <strong>if:</strong> status == in_ledger
		// </span><br/>
		// Current depth of the transaction in the local chain
		Depth *struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"depth,omitempty"`
		Direction string `json:"direction"`

		// A reference to a particular time slot.
		ExpiresAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"expires_at,omitempty"`

		// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
		Fee struct {
			Quantity int    `json:"quantity"`
			Unit     string `json:"unit"`
		} `json:"fee"`

		// A unique identifier for this transaction
		Id string `json:"id"`

		// A list of transaction inputs.
		//
		// `assets` and `address` are always present for `outgoing`
		// transactions but generally absent for `incoming`
		// transactions. This information is present on the Cardano explorer,
		// but is not tracked by the wallet.
		Inputs []struct {
			Address *string `json:"address,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount,omitempty"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`

			// A unique identifier for this transaction
			Id    string `json:"id"`
			Index int    `json:"index"`
		} `json:"inputs"`

		// A reference to a particular time slot, and the block height at that point.
		InsertedAt *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"inserted_at,omitempty"`

		// **⚠️ WARNING ⚠️**
		//
		// _Please note that metadata provided in a transaction will be
		// stored on the blockchain forever. Make sure not to include any sensitive data,
		// in particular personally identifiable information (PII)._
		//
		// Extra application data attached to the transaction.
		//
		// Cardano allows users and developers to embed their own
		// authenticated metadata when submitting transactions. Metadata can
		// be expressed as a JSON object with some restrictions:
		//
		// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
		//
		// 2. Each metadata value is tagged with its type.
		//
		// 3. Strings must be at most 64 bytes when UTF-8 encoded.
		//
		// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
		//
		// Metadata aren't stored as JSON on the Cardano blockchain but are
		// instead stored using a compact binary encoding (CBOR).
		//
		// The binary encoding of metadata values supports three simple types:
		//
		// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
		// * Strings (UTF-8 encoded)
		// * Bytestrings
		//
		// And two compound types:
		//
		// * Lists of metadata values
		// * Mappings from metadata values to metadata values
		//
		// It is possible to transform any JSON object into this schema.
		//
		// However, if your application uses floating point values, they will
		// need to be converted somehow, according to your
		// requirements. Likewise for `null` or `bool` values. When reading
		// metadata from chain, be aware that integers may exceed the
		// javascript numeric range, and may need special "bigint" parsing.
		Metadata *Metadata `json:"metadata"`

		// <p>status: <strong>⚠ under development</strong></p>
		//
		// _This field is not implemented yet, and will always be empty._
		//
		// Assets minted (created) or unminted (destroyed)
		//
		// This amount contributes to the total transaction value.
		//
		// Positive values denote creation of assets and negative values
		// denote the reverse.
		Mint []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint *string `json:"fingerprint,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`

			// Positive values mean creation and negative values mean
			// destruction.
			Quantity int `json:"quantity"`
		} `json:"mint"`

		// A list of target outputs
		Outputs []struct {
			Address string `json:"address"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// A flat list of assets.
			Assets *[]struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Number of assets for the given `policy_id` and `asset_name`.
				Quantity int `json:"quantity"`
			} `json:"assets,omitempty"`
		} `json:"outputs"`

		// A reference to a particular time slot, and the block height at that point.
		PendingSince *struct {

			// The 0-based slot index starting from genesis of the blockchain.
			AbsoluteSlotNumber int `json:"absolute_slot_number"`

			// An epoch is a time period which is divided into slots.
			EpochNumber int `json:"epoch_number"`
			Height      struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"height"`

			// The zero-based slot index within an epoch.
			SlotNumber int    `json:"slot_number"`
			Time       string `json:"time"`
		} `json:"pending_since,omitempty"`

		// Current transaction status.
		//
		//   ```
		//          *---------*          *-----------*
		//          |         |---------->  EXPIRED  |
		//          |         |  (ttl)   *-----------*
		//   -------> PENDING |
		//          |         <----------------*
		//          |         |                |
		//          *---------*            (rollback)
		//               |                     |
		//          (in ledger)          *-----------*
		//               |               |           |
		//               *---------------> IN_LEDGER |
		//                               |           |
		//                               *-----------*
		//   ```
		Status string `json:"status"`

		// A list of withdrawals from stake addresses.
		Withdrawals []struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`
			StakeAddress string `json:"stake_address"`
		} `json:"withdrawals"`
	}
	JSON404 *interface{}
	JSON406 *struct {
		Code string `json:"code"`

		// May occur when providing an invalid 'Accept' header.
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAnyAddressWithBodyWithResponse request with arbitrary body returning *PostAnyAddressResponse
func (c *ClientWithResponses) PostAnyAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostAnyAddressResponse, error) {
	rsp, err := c.PostAnyAddressWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostAnyAddressResponse(rsp)
}

func (c *ClientWithResponses) PostAnyAddressWithResponse(ctx context.Context, body PostAnyAddressJSONRequestBody) (*PostAnyAddressResponse, error) {
	rsp, err := c.PostAnyAddress(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostAnyAddressResponse(rsp)
}

// InspectAddressWithResponse request returning *InspectAddressResponse
func (c *ClientWithResponses) InspectAddressWithResponse(ctx context.Context, addressId string) (*InspectAddressResponse, error) {
	rsp, err := c.InspectAddress(ctx, addressId)
	if err != nil {
		return nil, err
	}
	return ParseInspectAddressResponse(rsp)
}

// ListByronWalletsWithResponse request returning *ListByronWalletsResponse
func (c *ClientWithResponses) ListByronWalletsWithResponse(ctx context.Context) (*ListByronWalletsResponse, error) {
	rsp, err := c.ListByronWallets(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListByronWalletsResponse(rsp)
}

// PostByronWalletWithBodyWithResponse request with arbitrary body returning *PostByronWalletResponse
func (c *ClientWithResponses) PostByronWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostByronWalletResponse, error) {
	rsp, err := c.PostByronWalletWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronWalletResponse(rsp)
}

func (c *ClientWithResponses) PostByronWalletWithResponse(ctx context.Context, body PostByronWalletJSONRequestBody) (*PostByronWalletResponse, error) {
	rsp, err := c.PostByronWallet(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronWalletResponse(rsp)
}

// DeleteByronWalletWithResponse request returning *DeleteByronWalletResponse
func (c *ClientWithResponses) DeleteByronWalletWithResponse(ctx context.Context, walletId string) (*DeleteByronWalletResponse, error) {
	rsp, err := c.DeleteByronWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteByronWalletResponse(rsp)
}

// GetByronWalletWithResponse request returning *GetByronWalletResponse
func (c *ClientWithResponses) GetByronWalletWithResponse(ctx context.Context, walletId string) (*GetByronWalletResponse, error) {
	rsp, err := c.GetByronWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetByronWalletResponse(rsp)
}

// PutByronWalletWithBodyWithResponse request with arbitrary body returning *PutByronWalletResponse
func (c *ClientWithResponses) PutByronWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutByronWalletResponse, error) {
	rsp, err := c.PutByronWalletWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutByronWalletResponse(rsp)
}

func (c *ClientWithResponses) PutByronWalletWithResponse(ctx context.Context, walletId string, body PutByronWalletJSONRequestBody) (*PutByronWalletResponse, error) {
	rsp, err := c.PutByronWallet(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePutByronWalletResponse(rsp)
}

// ListByronAddressesWithResponse request returning *ListByronAddressesResponse
func (c *ClientWithResponses) ListByronAddressesWithResponse(ctx context.Context, walletId string, params *ListByronAddressesParams) (*ListByronAddressesResponse, error) {
	rsp, err := c.ListByronAddresses(ctx, walletId, params)
	if err != nil {
		return nil, err
	}
	return ParseListByronAddressesResponse(rsp)
}

// CreateAddressWithBodyWithResponse request with arbitrary body returning *CreateAddressResponse
func (c *ClientWithResponses) CreateAddressWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*CreateAddressResponse, error) {
	rsp, err := c.CreateAddressWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddressResponse(rsp)
}

func (c *ClientWithResponses) CreateAddressWithResponse(ctx context.Context, walletId string, body CreateAddressJSONRequestBody) (*CreateAddressResponse, error) {
	rsp, err := c.CreateAddress(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddressResponse(rsp)
}

// ImportAddressesWithBodyWithResponse request with arbitrary body returning *ImportAddressesResponse
func (c *ClientWithResponses) ImportAddressesWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*ImportAddressesResponse, error) {
	rsp, err := c.ImportAddressesWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseImportAddressesResponse(rsp)
}

func (c *ClientWithResponses) ImportAddressesWithResponse(ctx context.Context, walletId string, body ImportAddressesJSONRequestBody) (*ImportAddressesResponse, error) {
	rsp, err := c.ImportAddresses(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseImportAddressesResponse(rsp)
}

// ImportAddressWithResponse request returning *ImportAddressResponse
func (c *ClientWithResponses) ImportAddressWithResponse(ctx context.Context, walletId string, addressId string) (*ImportAddressResponse, error) {
	rsp, err := c.ImportAddress(ctx, walletId, addressId)
	if err != nil {
		return nil, err
	}
	return ParseImportAddressResponse(rsp)
}

// ListByronAssetsWithResponse request returning *ListByronAssetsResponse
func (c *ClientWithResponses) ListByronAssetsWithResponse(ctx context.Context, walletId string) (*ListByronAssetsResponse, error) {
	rsp, err := c.ListByronAssets(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseListByronAssetsResponse(rsp)
}

// GetByronAssetDefaultWithResponse request returning *GetByronAssetDefaultResponse
func (c *ClientWithResponses) GetByronAssetDefaultWithResponse(ctx context.Context, walletId string, policyId string) (*GetByronAssetDefaultResponse, error) {
	rsp, err := c.GetByronAssetDefault(ctx, walletId, policyId)
	if err != nil {
		return nil, err
	}
	return ParseGetByronAssetDefaultResponse(rsp)
}

// GetByronAssetWithResponse request returning *GetByronAssetResponse
func (c *ClientWithResponses) GetByronAssetWithResponse(ctx context.Context, walletId string, policyId string, assetName string) (*GetByronAssetResponse, error) {
	rsp, err := c.GetByronAsset(ctx, walletId, policyId, assetName)
	if err != nil {
		return nil, err
	}
	return ParseGetByronAssetResponse(rsp)
}

// ByronSelectCoinsWithBodyWithResponse request with arbitrary body returning *ByronSelectCoinsResponse
func (c *ClientWithResponses) ByronSelectCoinsWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*ByronSelectCoinsResponse, error) {
	rsp, err := c.ByronSelectCoinsWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseByronSelectCoinsResponse(rsp)
}

func (c *ClientWithResponses) ByronSelectCoinsWithResponse(ctx context.Context, walletId string, body ByronSelectCoinsJSONRequestBody) (*ByronSelectCoinsResponse, error) {
	rsp, err := c.ByronSelectCoins(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseByronSelectCoinsResponse(rsp)
}

// GetByronWalletMigrationInfoWithResponse request returning *GetByronWalletMigrationInfoResponse
func (c *ClientWithResponses) GetByronWalletMigrationInfoWithResponse(ctx context.Context, walletId string) (*GetByronWalletMigrationInfoResponse, error) {
	rsp, err := c.GetByronWalletMigrationInfo(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetByronWalletMigrationInfoResponse(rsp)
}

// MigrateByronWalletWithBodyWithResponse request with arbitrary body returning *MigrateByronWalletResponse
func (c *ClientWithResponses) MigrateByronWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*MigrateByronWalletResponse, error) {
	rsp, err := c.MigrateByronWalletWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseMigrateByronWalletResponse(rsp)
}

func (c *ClientWithResponses) MigrateByronWalletWithResponse(ctx context.Context, walletId string, body MigrateByronWalletJSONRequestBody) (*MigrateByronWalletResponse, error) {
	rsp, err := c.MigrateByronWallet(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseMigrateByronWalletResponse(rsp)
}

// PutByronWalletPassphraseWithBodyWithResponse request with arbitrary body returning *PutByronWalletPassphraseResponse
func (c *ClientWithResponses) PutByronWalletPassphraseWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutByronWalletPassphraseResponse, error) {
	rsp, err := c.PutByronWalletPassphraseWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutByronWalletPassphraseResponse(rsp)
}

func (c *ClientWithResponses) PutByronWalletPassphraseWithResponse(ctx context.Context, walletId string, body PutByronWalletPassphraseJSONRequestBody) (*PutByronWalletPassphraseResponse, error) {
	rsp, err := c.PutByronWalletPassphrase(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePutByronWalletPassphraseResponse(rsp)
}

// PostByronTransactionFeeWithBodyWithResponse request with arbitrary body returning *PostByronTransactionFeeResponse
func (c *ClientWithResponses) PostByronTransactionFeeWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostByronTransactionFeeResponse, error) {
	rsp, err := c.PostByronTransactionFeeWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronTransactionFeeResponse(rsp)
}

func (c *ClientWithResponses) PostByronTransactionFeeWithResponse(ctx context.Context, walletId string, body PostByronTransactionFeeJSONRequestBody) (*PostByronTransactionFeeResponse, error) {
	rsp, err := c.PostByronTransactionFee(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronTransactionFeeResponse(rsp)
}

// GetByronUTxOsStatisticsWithResponse request returning *GetByronUTxOsStatisticsResponse
func (c *ClientWithResponses) GetByronUTxOsStatisticsWithResponse(ctx context.Context, walletId string) (*GetByronUTxOsStatisticsResponse, error) {
	rsp, err := c.GetByronUTxOsStatistics(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetByronUTxOsStatisticsResponse(rsp)
}

// ListByronTransactionsWithResponse request returning *ListByronTransactionsResponse
func (c *ClientWithResponses) ListByronTransactionsWithResponse(ctx context.Context, walletId string, params *ListByronTransactionsParams) (*ListByronTransactionsResponse, error) {
	rsp, err := c.ListByronTransactions(ctx, walletId, params)
	if err != nil {
		return nil, err
	}
	return ParseListByronTransactionsResponse(rsp)
}

// PostByronTransactionWithBodyWithResponse request with arbitrary body returning *PostByronTransactionResponse
func (c *ClientWithResponses) PostByronTransactionWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostByronTransactionResponse, error) {
	rsp, err := c.PostByronTransactionWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronTransactionResponse(rsp)
}

func (c *ClientWithResponses) PostByronTransactionWithResponse(ctx context.Context, walletId string, body PostByronTransactionJSONRequestBody) (*PostByronTransactionResponse, error) {
	rsp, err := c.PostByronTransaction(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePostByronTransactionResponse(rsp)
}

// DeleteByronTransactionWithResponse request returning *DeleteByronTransactionResponse
func (c *ClientWithResponses) DeleteByronTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*DeleteByronTransactionResponse, error) {
	rsp, err := c.DeleteByronTransaction(ctx, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteByronTransactionResponse(rsp)
}

// GetByronTransactionWithResponse request returning *GetByronTransactionResponse
func (c *ClientWithResponses) GetByronTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*GetByronTransactionResponse, error) {
	rsp, err := c.GetByronTransaction(ctx, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	return ParseGetByronTransactionResponse(rsp)
}

// GetNetworkClockWithResponse request returning *GetNetworkClockResponse
func (c *ClientWithResponses) GetNetworkClockWithResponse(ctx context.Context, params *GetNetworkClockParams) (*GetNetworkClockResponse, error) {
	rsp, err := c.GetNetworkClock(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkClockResponse(rsp)
}

// GetNetworkInformationWithResponse request returning *GetNetworkInformationResponse
func (c *ClientWithResponses) GetNetworkInformationWithResponse(ctx context.Context) (*GetNetworkInformationResponse, error) {
	rsp, err := c.GetNetworkInformation(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkInformationResponse(rsp)
}

// GetNetworkParametersWithResponse request returning *GetNetworkParametersResponse
func (c *ClientWithResponses) GetNetworkParametersWithResponse(ctx context.Context) (*GetNetworkParametersResponse, error) {
	rsp, err := c.GetNetworkParameters(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkParametersResponse(rsp)
}

// PostExternalTransactionWithBodyWithResponse request with arbitrary body returning *PostExternalTransactionResponse
func (c *ClientWithResponses) PostExternalTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostExternalTransactionResponse, error) {
	rsp, err := c.PostExternalTransactionWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostExternalTransactionResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// PutSettingsWithBodyWithResponse request with arbitrary body returning *PutSettingsResponse
func (c *ClientWithResponses) PutSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PutSettingsResponse, error) {
	rsp, err := c.PutSettingsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutSettingsResponse(rsp)
}

func (c *ClientWithResponses) PutSettingsWithResponse(ctx context.Context, body PutSettingsJSONRequestBody) (*PutSettingsResponse, error) {
	rsp, err := c.PutSettings(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePutSettingsResponse(rsp)
}

// PostSharedWalletWithBodyWithResponse request with arbitrary body returning *PostSharedWalletResponse
func (c *ClientWithResponses) PostSharedWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostSharedWalletResponse, error) {
	rsp, err := c.PostSharedWalletWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostSharedWalletResponse(rsp)
}

func (c *ClientWithResponses) PostSharedWalletWithResponse(ctx context.Context, body PostSharedWalletJSONRequestBody) (*PostSharedWalletResponse, error) {
	rsp, err := c.PostSharedWallet(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostSharedWalletResponse(rsp)
}

// DeleteSharedWalletWithResponse request returning *DeleteSharedWalletResponse
func (c *ClientWithResponses) DeleteSharedWalletWithResponse(ctx context.Context, walletId string) (*DeleteSharedWalletResponse, error) {
	rsp, err := c.DeleteSharedWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSharedWalletResponse(rsp)
}

// GetSharedWalletWithResponse request returning *GetSharedWalletResponse
func (c *ClientWithResponses) GetSharedWalletWithResponse(ctx context.Context, walletId string) (*GetSharedWalletResponse, error) {
	rsp, err := c.GetSharedWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetSharedWalletResponse(rsp)
}

// PatchSharedWalletInDelegationWithBodyWithResponse request with arbitrary body returning *PatchSharedWalletInDelegationResponse
func (c *ClientWithResponses) PatchSharedWalletInDelegationWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PatchSharedWalletInDelegationResponse, error) {
	rsp, err := c.PatchSharedWalletInDelegationWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchSharedWalletInDelegationResponse(rsp)
}

func (c *ClientWithResponses) PatchSharedWalletInDelegationWithResponse(ctx context.Context, walletId string, body PatchSharedWalletInDelegationJSONRequestBody) (*PatchSharedWalletInDelegationResponse, error) {
	rsp, err := c.PatchSharedWalletInDelegation(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchSharedWalletInDelegationResponse(rsp)
}

// PatchSharedWalletInPaymentWithBodyWithResponse request with arbitrary body returning *PatchSharedWalletInPaymentResponse
func (c *ClientWithResponses) PatchSharedWalletInPaymentWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PatchSharedWalletInPaymentResponse, error) {
	rsp, err := c.PatchSharedWalletInPaymentWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchSharedWalletInPaymentResponse(rsp)
}

func (c *ClientWithResponses) PatchSharedWalletInPaymentWithResponse(ctx context.Context, walletId string, body PatchSharedWalletInPaymentJSONRequestBody) (*PatchSharedWalletInPaymentResponse, error) {
	rsp, err := c.PatchSharedWalletInPayment(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchSharedWalletInPaymentResponse(rsp)
}

// GetCurrentSmashHealthWithResponse request returning *GetCurrentSmashHealthResponse
func (c *ClientWithResponses) GetCurrentSmashHealthWithResponse(ctx context.Context, params *GetCurrentSmashHealthParams) (*GetCurrentSmashHealthResponse, error) {
	rsp, err := c.GetCurrentSmashHealth(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentSmashHealthResponse(rsp)
}

// ListStakePoolsWithResponse request returning *ListStakePoolsResponse
func (c *ClientWithResponses) ListStakePoolsWithResponse(ctx context.Context, params *ListStakePoolsParams) (*ListStakePoolsResponse, error) {
	rsp, err := c.ListStakePools(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListStakePoolsResponse(rsp)
}

// QuitStakePoolWithBodyWithResponse request with arbitrary body returning *QuitStakePoolResponse
func (c *ClientWithResponses) QuitStakePoolWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*QuitStakePoolResponse, error) {
	rsp, err := c.QuitStakePoolWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseQuitStakePoolResponse(rsp)
}

func (c *ClientWithResponses) QuitStakePoolWithResponse(ctx context.Context, walletId string, body QuitStakePoolJSONRequestBody) (*QuitStakePoolResponse, error) {
	rsp, err := c.QuitStakePool(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseQuitStakePoolResponse(rsp)
}

// GetMaintenanceActionsWithResponse request returning *GetMaintenanceActionsResponse
func (c *ClientWithResponses) GetMaintenanceActionsWithResponse(ctx context.Context) (*GetMaintenanceActionsResponse, error) {
	rsp, err := c.GetMaintenanceActions(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetMaintenanceActionsResponse(rsp)
}

// PostMaintenanceActionWithBodyWithResponse request with arbitrary body returning *PostMaintenanceActionResponse
func (c *ClientWithResponses) PostMaintenanceActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostMaintenanceActionResponse, error) {
	rsp, err := c.PostMaintenanceActionWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMaintenanceActionResponse(rsp)
}

func (c *ClientWithResponses) PostMaintenanceActionWithResponse(ctx context.Context, body PostMaintenanceActionJSONRequestBody) (*PostMaintenanceActionResponse, error) {
	rsp, err := c.PostMaintenanceAction(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMaintenanceActionResponse(rsp)
}

// JoinStakePoolWithBodyWithResponse request with arbitrary body returning *JoinStakePoolResponse
func (c *ClientWithResponses) JoinStakePoolWithBodyWithResponse(ctx context.Context, stakePoolId string, walletId string, contentType string, body io.Reader) (*JoinStakePoolResponse, error) {
	rsp, err := c.JoinStakePoolWithBody(ctx, stakePoolId, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseJoinStakePoolResponse(rsp)
}

func (c *ClientWithResponses) JoinStakePoolWithResponse(ctx context.Context, stakePoolId string, walletId string, body JoinStakePoolJSONRequestBody) (*JoinStakePoolResponse, error) {
	rsp, err := c.JoinStakePool(ctx, stakePoolId, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseJoinStakePoolResponse(rsp)
}

// ListWalletsWithResponse request returning *ListWalletsResponse
func (c *ClientWithResponses) ListWalletsWithResponse(ctx context.Context) (*ListWalletsResponse, error) {
	rsp, err := c.ListWallets(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListWalletsResponse(rsp)
}

// PostWalletWithBodyWithResponse request with arbitrary body returning *PostWalletResponse
func (c *ClientWithResponses) PostWalletWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostWalletResponse, error) {
	rsp, err := c.PostWalletWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostWalletResponse(rsp)
}

func (c *ClientWithResponses) PostWalletWithResponse(ctx context.Context, body PostWalletJSONRequestBody) (*PostWalletResponse, error) {
	rsp, err := c.PostWallet(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostWalletResponse(rsp)
}

// DeleteWalletWithResponse request returning *DeleteWalletResponse
func (c *ClientWithResponses) DeleteWalletWithResponse(ctx context.Context, walletId string) (*DeleteWalletResponse, error) {
	rsp, err := c.DeleteWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWalletResponse(rsp)
}

// GetWalletWithResponse request returning *GetWalletResponse
func (c *ClientWithResponses) GetWalletWithResponse(ctx context.Context, walletId string) (*GetWalletResponse, error) {
	rsp, err := c.GetWallet(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletResponse(rsp)
}

// PutWalletWithBodyWithResponse request with arbitrary body returning *PutWalletResponse
func (c *ClientWithResponses) PutWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutWalletResponse, error) {
	rsp, err := c.PutWalletWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutWalletResponse(rsp)
}

func (c *ClientWithResponses) PutWalletWithResponse(ctx context.Context, walletId string, body PutWalletJSONRequestBody) (*PutWalletResponse, error) {
	rsp, err := c.PutWallet(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePutWalletResponse(rsp)
}

// ListAddressesWithResponse request returning *ListAddressesResponse
func (c *ClientWithResponses) ListAddressesWithResponse(ctx context.Context, walletId string, params *ListAddressesParams) (*ListAddressesResponse, error) {
	rsp, err := c.ListAddresses(ctx, walletId, params)
	if err != nil {
		return nil, err
	}
	return ParseListAddressesResponse(rsp)
}

// ListAssetsWithResponse request returning *ListAssetsResponse
func (c *ClientWithResponses) ListAssetsWithResponse(ctx context.Context, walletId string) (*ListAssetsResponse, error) {
	rsp, err := c.ListAssets(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseListAssetsResponse(rsp)
}

// GetAssetDefaultWithResponse request returning *GetAssetDefaultResponse
func (c *ClientWithResponses) GetAssetDefaultWithResponse(ctx context.Context, walletId string, policyId string) (*GetAssetDefaultResponse, error) {
	rsp, err := c.GetAssetDefault(ctx, walletId, policyId)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetDefaultResponse(rsp)
}

// GetAssetWithResponse request returning *GetAssetResponse
func (c *ClientWithResponses) GetAssetWithResponse(ctx context.Context, walletId string, policyId string, assetName string) (*GetAssetResponse, error) {
	rsp, err := c.GetAsset(ctx, walletId, policyId, assetName)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetResponse(rsp)
}

// SelectCoinsWithBodyWithResponse request with arbitrary body returning *SelectCoinsResponse
func (c *ClientWithResponses) SelectCoinsWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*SelectCoinsResponse, error) {
	rsp, err := c.SelectCoinsWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSelectCoinsResponse(rsp)
}

func (c *ClientWithResponses) SelectCoinsWithResponse(ctx context.Context, walletId string, body SelectCoinsJSONRequestBody) (*SelectCoinsResponse, error) {
	rsp, err := c.SelectCoins(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseSelectCoinsResponse(rsp)
}

// GetDelegationFeeWithResponse request returning *GetDelegationFeeResponse
func (c *ClientWithResponses) GetDelegationFeeWithResponse(ctx context.Context, walletId string) (*GetDelegationFeeResponse, error) {
	rsp, err := c.GetDelegationFee(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetDelegationFeeResponse(rsp)
}

// PostAccountKeyWithBodyWithResponse request with arbitrary body returning *PostAccountKeyResponse
func (c *ClientWithResponses) PostAccountKeyWithBodyWithResponse(ctx context.Context, walletId string, index string, contentType string, body io.Reader) (*PostAccountKeyResponse, error) {
	rsp, err := c.PostAccountKeyWithBody(ctx, walletId, index, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountKeyResponse(rsp)
}

func (c *ClientWithResponses) PostAccountKeyWithResponse(ctx context.Context, walletId string, index string, body PostAccountKeyJSONRequestBody) (*PostAccountKeyResponse, error) {
	rsp, err := c.PostAccountKey(ctx, walletId, index, body)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountKeyResponse(rsp)
}

// GetWalletKeyWithResponse request returning *GetWalletKeyResponse
func (c *ClientWithResponses) GetWalletKeyWithResponse(ctx context.Context, walletId string, role string, index string) (*GetWalletKeyResponse, error) {
	rsp, err := c.GetWalletKey(ctx, walletId, role, index)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletKeyResponse(rsp)
}

// GetShelleyWalletMigrationInfoWithResponse request returning *GetShelleyWalletMigrationInfoResponse
func (c *ClientWithResponses) GetShelleyWalletMigrationInfoWithResponse(ctx context.Context, walletId string) (*GetShelleyWalletMigrationInfoResponse, error) {
	rsp, err := c.GetShelleyWalletMigrationInfo(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetShelleyWalletMigrationInfoResponse(rsp)
}

// MigrateShelleyWalletWithBodyWithResponse request with arbitrary body returning *MigrateShelleyWalletResponse
func (c *ClientWithResponses) MigrateShelleyWalletWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*MigrateShelleyWalletResponse, error) {
	rsp, err := c.MigrateShelleyWalletWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseMigrateShelleyWalletResponse(rsp)
}

func (c *ClientWithResponses) MigrateShelleyWalletWithResponse(ctx context.Context, walletId string, body MigrateShelleyWalletJSONRequestBody) (*MigrateShelleyWalletResponse, error) {
	rsp, err := c.MigrateShelleyWallet(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParseMigrateShelleyWalletResponse(rsp)
}

// PutWalletPassphraseWithBodyWithResponse request with arbitrary body returning *PutWalletPassphraseResponse
func (c *ClientWithResponses) PutWalletPassphraseWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PutWalletPassphraseResponse, error) {
	rsp, err := c.PutWalletPassphraseWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutWalletPassphraseResponse(rsp)
}

func (c *ClientWithResponses) PutWalletPassphraseWithResponse(ctx context.Context, walletId string, body PutWalletPassphraseJSONRequestBody) (*PutWalletPassphraseResponse, error) {
	rsp, err := c.PutWalletPassphrase(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePutWalletPassphraseResponse(rsp)
}

// PostTransactionFeeWithBodyWithResponse request with arbitrary body returning *PostTransactionFeeResponse
func (c *ClientWithResponses) PostTransactionFeeWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostTransactionFeeResponse, error) {
	rsp, err := c.PostTransactionFeeWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionFeeResponse(rsp)
}

func (c *ClientWithResponses) PostTransactionFeeWithResponse(ctx context.Context, walletId string, body PostTransactionFeeJSONRequestBody) (*PostTransactionFeeResponse, error) {
	rsp, err := c.PostTransactionFee(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionFeeResponse(rsp)
}

// SignMetadataWithBodyWithResponse request with arbitrary body returning *SignMetadataResponse
func (c *ClientWithResponses) SignMetadataWithBodyWithResponse(ctx context.Context, walletId string, role string, index string, contentType string, body io.Reader) (*SignMetadataResponse, error) {
	rsp, err := c.SignMetadataWithBody(ctx, walletId, role, index, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSignMetadataResponse(rsp)
}

func (c *ClientWithResponses) SignMetadataWithResponse(ctx context.Context, walletId string, role string, index string, body SignMetadataJSONRequestBody) (*SignMetadataResponse, error) {
	rsp, err := c.SignMetadata(ctx, walletId, role, index, body)
	if err != nil {
		return nil, err
	}
	return ParseSignMetadataResponse(rsp)
}

// GetUTxOsStatisticsWithResponse request returning *GetUTxOsStatisticsResponse
func (c *ClientWithResponses) GetUTxOsStatisticsWithResponse(ctx context.Context, walletId string) (*GetUTxOsStatisticsResponse, error) {
	rsp, err := c.GetUTxOsStatistics(ctx, walletId)
	if err != nil {
		return nil, err
	}
	return ParseGetUTxOsStatisticsResponse(rsp)
}

// ListTransactionsWithResponse request returning *ListTransactionsResponse
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, walletId string, params *ListTransactionsParams) (*ListTransactionsResponse, error) {
	rsp, err := c.ListTransactions(ctx, walletId, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResponse(rsp)
}

// PostTransactionWithBodyWithResponse request with arbitrary body returning *PostTransactionResponse
func (c *ClientWithResponses) PostTransactionWithBodyWithResponse(ctx context.Context, walletId string, contentType string, body io.Reader) (*PostTransactionResponse, error) {
	rsp, err := c.PostTransactionWithBody(ctx, walletId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionResponse(rsp)
}

func (c *ClientWithResponses) PostTransactionWithResponse(ctx context.Context, walletId string, body PostTransactionJSONRequestBody) (*PostTransactionResponse, error) {
	rsp, err := c.PostTransaction(ctx, walletId, body)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, walletId string, transactionId string) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, walletId, transactionId)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// ParsePostAnyAddressResponse parses an HTTP response from a PostAnyAddressWithResponse call
func ParsePostAnyAddressResponse(rsp *http.Response) (*PostAnyAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostAnyAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A Shelley address representing either enterprise, reward account or delegating address
			Address string `json:"address"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseInspectAddressResponse parses an HTTP response from a InspectAddressWithResponse call
func ParseInspectAddressResponse(rsp *http.Response) (*InspectAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InspectAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Only for 'Icarus' and 'Byron' styles.
			AddressRoot  *string `json:"address_root,omitempty"`
			AddressStyle string  `json:"address_style"`

			// Only for 'Byron' style.
			DerivationPath *string `json:"derivation_path,omitempty"`

			// Can be null for 'Icarus' and 'Byron' styles.
			NetworkTag *int `json:"network_tag,omitempty"`
			Pointer    *struct {
				OutputIndex      int `json:"output_index"`
				SlotNum          int `json:"slot_num"`
				TransactionIndex int `json:"transaction_index"`
			} `json:"pointer,omitempty"`
			ScriptHash        *string `json:"script_hash,omitempty"`
			ScriptHashBech32  *string `json:"script_hash_bech32,omitempty"`
			SpendingKeyBech32 *string `json:"spending_key_bech32,omitempty"`
			SpendingKeyHash   *string `json:"spending_key_hash,omitempty"`
			StakeKeyBech32    *string `json:"stake_key_bech32,omitempty"`
			StakeKeyHash      *string `json:"stake_key_hash,omitempty"`
			StakeReference    string  `json:"stake_reference"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListByronWalletsResponse parses an HTTP response from a ListByronWalletsWithResponse call
func ParseListByronWalletsResponse(rsp *http.Response) (*ListByronWalletsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListByronWalletsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Byron wallet's current balance(s)
			Balance struct {

				// Available balance (funds that can be spent)
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// Total balance (available balance plus pending change)
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Mechanism used for discovering addresses.
			Discovery string `json:"discovery"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostByronWalletResponse parses an HTTP response from a PostByronWalletWithResponse call
func ParsePostByronWalletResponse(rsp *http.Response) (*PostByronWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostByronWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Byron wallet's current balance(s)
			Balance struct {

				// Available balance (funds that can be spent)
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// Total balance (available balance plus pending change)
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Mechanism used for discovering addresses.
			Discovery string `json:"discovery"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseDeleteByronWalletResponse parses an HTTP response from a DeleteByronWalletWithResponse call
func ParseDeleteByronWalletResponse(rsp *http.Response) (*DeleteByronWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteByronWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetByronWalletResponse parses an HTTP response from a GetByronWalletWithResponse call
func ParseGetByronWalletResponse(rsp *http.Response) (*GetByronWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Byron wallet's current balance(s)
			Balance struct {

				// Available balance (funds that can be spent)
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// Total balance (available balance plus pending change)
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Mechanism used for discovering addresses.
			Discovery string `json:"discovery"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePutByronWalletResponse parses an HTTP response from a PutByronWalletWithResponse call
func ParsePutByronWalletResponse(rsp *http.Response) (*PutByronWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutByronWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Number of consecutive unused addresses allowed.
			//
			// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
			// your wallet in a different software which is strictly following BIP-44.
			//
			// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
			AddressPoolGap int `json:"address_pool_gap"`

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Wallet current Ada balance(s).
			Balance struct {

				// Available Ada UTxO balance (funds that can be spent without condition).
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// The Ada balance of the reward account for this wallet.
				Reward struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"reward"`

				// Total Ada balance (available balance plus pending change and reward balance).
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Delegation settings
			Delegation struct {

				// Currently active delegation status.
				Active struct {
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"active"`
				Next []struct {
					ChangesAt struct {

						// An epoch is a time period which is divided into slots.
						EpochNumber    int    `json:"epoch_number"`
						EpochStartTime string `json:"epoch_start_time"`
					} `json:"changes_at"`
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"next"`
			} `json:"delegation"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseListByronAddressesResponse parses an HTTP response from a ListByronAddressesWithResponse call
func ParseListByronAddressesResponse(rsp *http.Response) (*ListByronAddressesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListByronAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
			Id             string   `json:"id"`
			State          string   `json:"state"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseCreateAddressResponse parses an HTTP response from a CreateAddressWithResponse call
func ParseCreateAddressResponse(rsp *http.Response) (*CreateAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
			Id             string   `json:"id"`
			State          string   `json:"state"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseImportAddressesResponse parses an HTTP response from a ImportAddressesWithResponse call
func ParseImportAddressesResponse(rsp *http.Response) (*ImportAddressesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseImportAddressResponse parses an HTTP response from a ImportAddressWithResponse call
func ParseImportAddressResponse(rsp *http.Response) (*ImportAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListByronAssetsResponse parses an HTTP response from a ListByronAssetsWithResponse call
func ParseListByronAssetsResponse(rsp *http.Response) (*ListByronAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListByronAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetByronAssetDefaultResponse parses an HTTP response from a GetByronAssetDefaultWithResponse call
func ParseGetByronAssetDefaultResponse(rsp *http.Response) (*GetByronAssetDefaultResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronAssetDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// Occurs when requesting information about an asset which is not
			// involved in any transaction related to the wallet.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetByronAssetResponse parses an HTTP response from a GetByronAssetWithResponse call
func ParseGetByronAssetResponse(rsp *http.Response) (*GetByronAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// Occurs when requesting information about an asset which is not
			// involved in any transaction related to the wallet.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseByronSelectCoinsResponse parses an HTTP response from a ByronSelectCoinsWithResponse call
func ParseByronSelectCoinsResponse(rsp *http.Response) (*ByronSelectCoinsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ByronSelectCoinsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Certificates *[]struct {
				CertificateType string `json:"certificate_type"`

				// A unique identifier for the pool.
				Pool              *string  `json:"pool,omitempty"`
				RewardAccountPath []string `json:"reward_account_path"`
			} `json:"certificates,omitempty"`

			// A list of transaction change outputs.
			Change []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`
			} `json:"change"`

			// A list of deposits associated with a transaction.
			Deposits *[]struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposits,omitempty"`

			// A list of transaction inputs
			Inputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
			Metadata *string `json:"metadata,omitempty"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A list of withdrawals from stake addresses.
			Withdrawals *[]struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`
				StakeAddress   string   `json:"stake_address"`
			} `json:"withdrawals,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetByronWalletMigrationInfoResponse parses an HTTP response from a GetByronWalletMigrationInfoWithResponse call
func ParseGetByronWalletMigrationInfoResponse(rsp *http.Response) (*GetByronWalletMigrationInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronWalletMigrationInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Leftovers dust coins which won't be migrated nor spent as fees.
			Leftovers struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"leftovers"`

			// Total amount which will be paid as fees for the migration.
			MigrationCost struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"migration_cost"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code string `json:"code"`

			// May occur when trying to migrate a wallet that is empty or full of dust.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseMigrateByronWalletResponse parses an HTTP response from a MigrateByronWalletWithResponse call
func ParseMigrateByronWalletResponse(rsp *http.Response) (*MigrateByronWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MigrateByronWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParsePutByronWalletPassphraseResponse parses an HTTP response from a PutByronWalletPassphraseWithResponse call
func ParsePutByronWalletPassphraseResponse(rsp *http.Response) (*PutByronWalletPassphraseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutByronWalletPassphraseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParsePostByronTransactionFeeResponse parses an HTTP response from a PostByronTransactionFeeWithResponse call
func ParsePostByronTransactionFeeResponse(rsp *http.Response) (*PostByronTransactionFeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostByronTransactionFeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMax struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_max"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMin struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_min"`

			// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
			//
			//   - (a) Some updatable protocol parameters fixed by the network.
			//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
			//
			// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
			// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
			// when calculating fee for delegation), this list is empty.
			//
			// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
			// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
			//
			// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
			// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
			MinimumCoins []struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"minimum_coins"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetByronUTxOsStatisticsResponse parses an HTTP response from a GetByronUTxOsStatisticsWithResponse call
func ParseGetByronUTxOsStatisticsResponse(rsp *http.Response) (*GetByronUTxOsStatisticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronUTxOsStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Distribution Distribution `json:"distribution"`
			Scale        string       `json:"scale"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListByronTransactionsResponse parses an HTTP response from a ListByronTransactionsWithResponse call
func ParseListByronTransactionsResponse(rsp *http.Response) (*ListByronTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListByronTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostByronTransactionResponse parses an HTTP response from a PostByronTransactionWithResponse call
func ParsePostByronTransactionResponse(rsp *http.Response) (*PostByronTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostByronTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseDeleteByronTransactionResponse parses an HTTP response from a DeleteByronTransactionWithResponse call
func ParseDeleteByronTransactionResponse(rsp *http.Response) (*DeleteByronTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteByronTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code string `json:"code"`

			// Occurs when attempting to delete a transaction which is neither pending nor expired.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetByronTransactionResponse parses an HTTP response from a GetByronTransactionWithResponse call
func ParseGetByronTransactionResponse(rsp *http.Response) (*GetByronTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetByronTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetNetworkClockResponse parses an HTTP response from a GetNetworkClockWithResponse call
func ParseGetNetworkClockResponse(rsp *http.Response) (*GetNetworkClockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkClockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == available
			// </span><br/>
			// Drift offset of the local clock.
			Offset *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"offset,omitempty"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetNetworkInformationResponse parses an HTTP response from a GetNetworkInformationWithResponse call
func ParseGetNetworkInformationResponse(rsp *http.Response) (*GetNetworkInformationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The time slot corresponding the network tip.
			NetworkTip *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"network_tip,omitempty"`
			NextEpoch *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"next_epoch,omitempty"`
			NodeEra string `json:"node_era"`

			// Underlying node's tip
			NodeTip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"node_tip"`

			// Estimated synchronization progress of the node with the underlying network. Note that this may
			// change quite arbitrarily as the node may switch to shorter or longer chain forks.
			SyncProgress struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"sync_progress"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetNetworkParametersResponse parses an HTTP response from a GetNetworkParametersWithResponse call
func ParseGetNetworkParametersResponse(rsp *http.Response) (*GetNetworkParametersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkParametersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ActiveSlotCoefficient struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"active_slot_coefficient"`
			BlockchainStartTime   string `json:"blockchain_start_time"`
			DecentralizationLevel struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"decentralization_level"`
			DesiredPoolNumber int `json:"desired_pool_number"`
			EpochLength       struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"epoch_length"`

			//
			// If and when each era started or will start.
			//
			// The object is keyed by era names. The values either describe the epoch boundary
			// when the era starts (can be in the future or in the past), or are null if not yet
			// confirmed on-chain.
			//
			// If you need to know the current era, see the `node_era` field of
			// `GET /network/information`.
			//
			// > Due to complications with our current tooling, we cannot mark the era names
			// > as required, but the keys are in fact always present.
			Eras struct {
				Allegra *struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"allegra"`
				Byron *struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"byron"`
				Mary *struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"mary"`
				Shelley *struct {

					// An epoch is a time period which is divided into slots.
					EpochNumber    int    `json:"epoch_number"`
					EpochStartTime string `json:"epoch_start_time"`
				} `json:"shelley"`
			} `json:"eras"`

			// The hash of genesis block
			GenesisBlockHash string `json:"genesis_block_hash"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			MinimumUtxoValue struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"minimum_utxo_value"`
			SecurityParameter struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"security_parameter"`
			SlotLength struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"slot_length"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostExternalTransactionResponse parses an HTTP response from a PostExternalTransactionWithResponse call
func ParsePostExternalTransactionResponse(rsp *http.Response) (*PostExternalTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostExternalTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A unique identifier for this transaction
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Pool metadata source. This sets the metadata fetching strategy.
			//
			// Possible values are
			//   * none -> no fetching
			//   * direct -> direct fetching
			//   * uri -> use SMASH server
			PoolMetadataSource string `json:"pool_metadata_source"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParsePutSettingsResponse parses an HTTP response from a PutSettingsWithResponse call
func ParsePutSettingsResponse(rsp *http.Response) (*PutSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParsePostSharedWalletResponse parses an HTTP response from a PostSharedWalletWithResponse call
func ParsePostSharedWalletResponse(rsp *http.Response) (*PostSharedWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostSharedWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Code string `json:"code"`

			// May occur when a otherwise valid request would yield a wallet that already exists.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseDeleteSharedWalletResponse parses an HTTP response from a DeleteSharedWalletWithResponse call
func ParseDeleteSharedWalletResponse(rsp *http.Response) (*DeleteSharedWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteSharedWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetSharedWalletResponse parses an HTTP response from a GetSharedWalletWithResponse call
func ParseGetSharedWalletResponse(rsp *http.Response) (*GetSharedWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSharedWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePatchSharedWalletInDelegationResponse parses an HTTP response from a PatchSharedWalletInDelegationWithResponse call
func ParsePatchSharedWalletInDelegationResponse(rsp *http.Response) (*PatchSharedWalletInDelegationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchSharedWalletInDelegationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePatchSharedWalletInPaymentResponse parses an HTTP response from a PatchSharedWalletInPaymentWithResponse call
func ParsePatchSharedWalletInPaymentResponse(rsp *http.Response) (*PatchSharedWalletInPaymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchSharedWalletInPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetCurrentSmashHealthResponse parses an HTTP response from a GetCurrentSmashHealthWithResponse call
func ParseGetCurrentSmashHealthResponse(rsp *http.Response) (*GetCurrentSmashHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentSmashHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Health string `json:"health"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListStakePoolsResponse parses an HTTP response from a ListStakePoolsWithResponse call
func ParseListStakePoolsResponse(rsp *http.Response) (*ListStakePoolsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListStakePoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// Estimated cost set by the pool operator when registering his pool.
			// This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
			//
			// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
			Cost struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"cost"`

			// Various flags applicable to stake pools. Possible flags:
			//
			// | flag     | description                                                                                                      |
			// | ---      | ---                                                                                                              |
			// | delisted | The pool is marked as delisted on a configured SMASH server; metadata for this pool have therefore been dropped. |
			Flags []string `json:"flags"`

			// A unique identifier for the pool.
			Id string `json:"id"`

			// Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
			//
			// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
			Margin struct {
				Quantity float32 `json:"quantity"`
				Unit     string  `json:"unit"`
			} `json:"margin"`

			// Information about the stake pool.
			Metadata *struct {
				Description *string `json:"description,omitempty"`
				Homepage    string  `json:"homepage"`
				Name        string  `json:"name"`
				Ticker      string  `json:"ticker"`
			} `json:"metadata,omitempty"`
			Metrics struct {

				// The rewards the wallet can expect to receive at the end of an epoch, in the long term, if delegating to
				// this pool.
				//
				// For more details, see the
				// [Design Specification for Delegation and Incentives in Cardano](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec)
				// document.
				NonMyopicMemberRewards struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"non_myopic_member_rewards"`

				// Number of blocks produced by a given stake pool in its lifetime.
				ProducedBlocks struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"produced_blocks"`

				// The live pool stake relative to the *total* stake.
				//
				// For more details, see the section "Relative Stake: Active vs Total" in
				// [Design Specification for Delegation and Incentives in Cardano](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec).
				RelativeStake struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"relative_stake"`

				// Saturation-level of the pool based on the desired number of pools aimed by the network.
				// A value above `1` indicates that the pool is saturated.
				//
				// The `non_myopic_member_rewards` take oversaturation into account, as specified by the [specs](https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/delegationDesignSpec/latest/download-by-type/doc-pdf/delegation_design_spec).
				//
				// The saturation is based on the live `relative_stake`. The saturation at the end of epoch e,
				// will affect the rewards paid out at the end of epoch e+3.
				Saturation float32 `json:"saturation"`
			} `json:"metrics"`

			// Minimal stake amount that a stake pool is willing to honor.
			//
			// May be omitted if the wallet hasn't found the pool's registration cerificate yet.
			Pledge struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"pledge"`

			// The epoch in which a stake pool retires.
			//
			// May be omitted if the wallet hasn't yet found a retirement certificate
			// for this stake pool.
			Retirement *struct {

				// An epoch is a time period which is divided into slots.
				EpochNumber    int    `json:"epoch_number"`
				EpochStartTime string `json:"epoch_start_time"`
			} `json:"retirement,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when an endpoint requires the presence of a query parameter that is missing.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseQuitStakePoolResponse parses an HTTP response from a QuitStakePoolWithResponse call
func ParseQuitStakePoolResponse(rsp *http.Response) (*QuitStakePoolResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &QuitStakePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetMaintenanceActionsResponse parses an HTTP response from a GetMaintenanceActionsWithResponse call
func ParseGetMaintenanceActionsResponse(rsp *http.Response) (*GetMaintenanceActionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMaintenanceActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Gives an indication if metadata GC checking for delisted pools
			// has run and if so, when.
			//
			// Possible values are:
			//   - not_applicable -> we're currently not querying a SMASH server for metadata
			//   - not_started -> the GC hasn't started yet, try again in a short while
			//   - restarting -> the GC thread is currently restarting, try again in short while
			//   - has_run -> the GC has run successfully
			//
			// When 'status' is 'restarting' or 'has_run' then the field 'last_run'
			// is set to the last GC time in UTC.
			GcStakePools struct {
				LastRun *string `json:"last_run,omitempty"`
				Status  string  `json:"status"`
			} `json:"gc_stake_pools"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParsePostMaintenanceActionResponse parses an HTTP response from a PostMaintenanceActionWithResponse call
func ParsePostMaintenanceActionResponse(rsp *http.Response) (*PostMaintenanceActionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostMaintenanceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest
	}

	return response, nil
}

// ParseJoinStakePoolResponse parses an HTTP response from a JoinStakePoolWithResponse call
func ParseJoinStakePoolResponse(rsp *http.Response) (*JoinStakePoolResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JoinStakePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseListWalletsResponse parses an HTTP response from a ListWalletsWithResponse call
func ParseListWalletsResponse(rsp *http.Response) (*ListWalletsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListWalletsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// Number of consecutive unused addresses allowed.
			//
			// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
			// your wallet in a different software which is strictly following BIP-44.
			//
			// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
			AddressPoolGap int `json:"address_pool_gap"`

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Wallet current Ada balance(s).
			Balance struct {

				// Available Ada UTxO balance (funds that can be spent without condition).
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// The Ada balance of the reward account for this wallet.
				Reward struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"reward"`

				// Total Ada balance (available balance plus pending change and reward balance).
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Delegation settings
			Delegation struct {

				// Currently active delegation status.
				Active struct {
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"active"`
				Next []struct {
					ChangesAt struct {

						// An epoch is a time period which is divided into slots.
						EpochNumber    int    `json:"epoch_number"`
						EpochStartTime string `json:"epoch_start_time"`
					} `json:"changes_at"`
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"next"`
			} `json:"delegation"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostWalletResponse parses an HTTP response from a PostWalletWithResponse call
func ParsePostWalletResponse(rsp *http.Response) (*PostWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// Number of consecutive unused addresses allowed.
			//
			// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
			// your wallet in a different software which is strictly following BIP-44.
			//
			// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
			AddressPoolGap int `json:"address_pool_gap"`

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Wallet current Ada balance(s).
			Balance struct {

				// Available Ada UTxO balance (funds that can be spent without condition).
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// The Ada balance of the reward account for this wallet.
				Reward struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"reward"`

				// Total Ada balance (available balance plus pending change and reward balance).
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Delegation settings
			Delegation struct {

				// Currently active delegation status.
				Active struct {
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"active"`
				Next []struct {
					ChangesAt struct {

						// An epoch is a time period which is divided into slots.
						EpochNumber    int    `json:"epoch_number"`
						EpochStartTime string `json:"epoch_start_time"`
					} `json:"changes_at"`
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"next"`
			} `json:"delegation"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Code string `json:"code"`

			// May occur when a otherwise valid request would yield a wallet that already exists.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseDeleteWalletResponse parses an HTTP response from a DeleteWalletWithResponse call
func ParseDeleteWalletResponse(rsp *http.Response) (*DeleteWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetWalletResponse parses an HTTP response from a GetWalletWithResponse call
func ParseGetWalletResponse(rsp *http.Response) (*GetWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Number of consecutive unused addresses allowed.
			//
			// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
			// your wallet in a different software which is strictly following BIP-44.
			//
			// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
			AddressPoolGap int `json:"address_pool_gap"`

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Wallet current Ada balance(s).
			Balance struct {

				// Available Ada UTxO balance (funds that can be spent without condition).
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// The Ada balance of the reward account for this wallet.
				Reward struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"reward"`

				// Total Ada balance (available balance plus pending change and reward balance).
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Delegation settings
			Delegation struct {

				// Currently active delegation status.
				Active struct {
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"active"`
				Next []struct {
					ChangesAt struct {

						// An epoch is a time period which is divided into slots.
						EpochNumber    int    `json:"epoch_number"`
						EpochStartTime string `json:"epoch_start_time"`
					} `json:"changes_at"`
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"next"`
			} `json:"delegation"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePutWalletResponse parses an HTTP response from a PutWalletWithResponse call
func ParsePutWalletResponse(rsp *http.Response) (*PutWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Number of consecutive unused addresses allowed.
			//
			// **IMPORTANT DISCLAIMER:** Using values other than `20` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
			// your wallet in a different software which is strictly following BIP-44.
			//
			// Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
			AddressPoolGap int `json:"address_pool_gap"`

			// Current non-Ada asset holdings of the wallet.
			//
			// The amount of assets available to spend may be less than the total
			// unspent assets due to transaction change amounts which are yet to
			// be fully confirmed (pending).
			Assets struct {

				// Available UTxO asset balances (funds that can be spent without
				// condition).
				Available []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"available"`

				// Total asset balances (available balances plus pending change balances).
				Total []struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"total"`
			} `json:"assets"`

			// Wallet current Ada balance(s).
			Balance struct {

				// Available Ada UTxO balance (funds that can be spent without condition).
				Available struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"available"`

				// The Ada balance of the reward account for this wallet.
				Reward struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"reward"`

				// Total Ada balance (available balance plus pending change and reward balance).
				Total struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"total"`
			} `json:"balance"`

			// Delegation settings
			Delegation struct {

				// Currently active delegation status.
				Active struct {
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"active"`
				Next []struct {
					ChangesAt struct {

						// An epoch is a time period which is divided into slots.
						EpochNumber    int    `json:"epoch_number"`
						EpochStartTime string `json:"epoch_start_time"`
					} `json:"changes_at"`
					Status string `json:"status"`

					// A unique Stake-Pool identifier (present only if status = `delegating`)
					Target *string `json:"target,omitempty"`
				} `json:"next"`
			} `json:"delegation"`

			// A unique identifier for the wallet
			Id   string `json:"id"`
			Name string `json:"name"`

			// Information about the wallet's passphrase
			Passphrase *struct {
				LastUpdatedAt string `json:"last_updated_at"`
			} `json:"passphrase,omitempty"`

			// Whether a wallet is ready to use or still syncing
			State struct {

				// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
				// <strong>if:</strong> status == syncing
				// </span><br/>
				Progress *struct {
					Quantity float32 `json:"quantity"`
					Unit     string  `json:"unit"`
				} `json:"progress,omitempty"`
				Status string `json:"status"`
			} `json:"state"`

			// A reference to a particular time slot, and the block height at that point.
			Tip struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"tip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseListAddressesResponse parses an HTTP response from a ListAddressesWithResponse call
func ParseListAddressesResponse(rsp *http.Response) (*ListAddressesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// A path for deriving a child key from a parent key.
			DerivationPath []string `json:"derivation_path"`
			Id             string   `json:"id"`
			State          string   `json:"state"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListAssetsResponse parses an HTTP response from a ListAssetsWithResponse call
func ParseListAssetsResponse(rsp *http.Response) (*ListAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetAssetDefaultResponse parses an HTTP response from a GetAssetDefaultWithResponse call
func ParseGetAssetDefaultResponse(rsp *http.Response) (*GetAssetDefaultResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAssetDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// Occurs when requesting information about an asset which is not
			// involved in any transaction related to the wallet.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetAssetResponse parses an HTTP response from a GetAssetWithResponse call
func ParseGetAssetResponse(rsp *http.Response) (*GetAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The asset on-chain type which acts as a sub-identifier within a
			// policy. Although we call it "asset name", the value needn't be
			// text, and it could even be empty.
			//
			// For policies with a single fungible asset item, asset name is
			// typically an empty string.
			//
			// This value can be up to 32 bytes of arbitrary data (which is 64
			// hexadecimal digits).
			AssetName string `json:"asset_name"`

			// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
			// to allow for an easier human comparison of assets. Note that it is generally
			// **not okay** to use this fingerprint as a unique identifier for it is not collision
			// resistant. Yet within the context of a single wallet, it makes for a (rather)
			// short user-facing comparison mean.
			Fingerprint string `json:"fingerprint"`

			// In the Mary era of Cardano, UTxO may contain native assets. These
			// assets are represented on-chain by opaque identifiers which are
			// meaningless to end-users. Therefore, user-facing metadata
			// regarding each token must be stored off-chain, in a metadata
			// registry.
			//
			// Token creators may publish metadata into the registry and client
			// applications can consume these metadata for display to end
			// users. This will work in a similar way to how it is done for stake
			// pool metadata.
			Metadata *struct {

				// A human-readable description for the asset. Good for display in
				// user interfaces.
				Description string `json:"description"`

				// A base64-encoded `image/png` for displaying the asset. The end image can be expected
				// to be smaller than 64KB.
				Logo *string `json:"logo,omitempty"`

				// A human-readable name for the asset, intended for display in user
				// interfaces.
				Name string `json:"name"`

				// An optional human-readable very short name or acronym for the
				// asset, intended for display in user interfaces. If `ticker` is not
				// present, then `name` will be used, but it might be truncated to
				// fit within the available space.
				Ticker *string `json:"ticker,omitempty"`

				// Defines a larger unit for the asset, in the same way Ada is the
				// larger unit of Lovelace.
				Unit *struct {

					// The number of digits after the decimal point.
					Decimals int `json:"decimals"`

					// The human-readable name for the larger unit of the asset. Used
					// for display in user interfaces.
					Name string `json:"name"`
				} `json:"unit,omitempty"`

				// A URL to the policy's owner(s) or the entity website in charge of the asset.
				Url *string `json:"url,omitempty"`
			} `json:"metadata,omitempty"`

			// A unique identifier of the asset's monetary policy. The policy
			// controls how assets of this kind are created and destroyed.
			//
			// The contents are the blake2b-224 hash of the monetary policy
			// script, encoded in hexadecimal.
			PolicyId string `json:"policy_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// Occurs when requesting information about an asset which is not
			// involved in any transaction related to the wallet.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseSelectCoinsResponse parses an HTTP response from a SelectCoinsWithResponse call
func ParseSelectCoinsResponse(rsp *http.Response) (*SelectCoinsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SelectCoinsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Certificates *[]struct {
				CertificateType string `json:"certificate_type"`

				// A unique identifier for the pool.
				Pool              *string  `json:"pool,omitempty"`
				RewardAccountPath []string `json:"reward_account_path"`
			} `json:"certificates,omitempty"`

			// A list of transaction change outputs.
			Change []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`
			} `json:"change"`

			// A list of deposits associated with a transaction.
			Deposits *[]struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposits,omitempty"`

			// A list of transaction inputs
			Inputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
			Metadata *string `json:"metadata,omitempty"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A list of withdrawals from stake addresses.
			Withdrawals *[]struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A path for deriving a child key from a parent key.
				DerivationPath []string `json:"derivation_path"`
				StakeAddress   string   `json:"stake_address"`
			} `json:"withdrawals,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetDelegationFeeResponse parses an HTTP response from a GetDelegationFeeWithResponse call
func ParseGetDelegationFeeResponse(rsp *http.Response) (*GetDelegationFeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDelegationFeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMax struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_max"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMin struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_min"`

			// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
			//
			//   - (a) Some updatable protocol parameters fixed by the network.
			//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
			//
			// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
			// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
			// when calculating fee for delegation), this list is empty.
			//
			// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
			// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
			//
			// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
			// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
			MinimumCoins []struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"minimum_coins"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code string `json:"code"`

			// May occur when a transaction can't be balanced for fees.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostAccountKeyResponse parses an HTTP response from a PostAccountKeyWithResponse call
func ParsePostAccountKeyResponse(rsp *http.Response) (*PostAccountKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostAccountKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetWalletKeyResponse parses an HTTP response from a GetWalletKeyWithResponse call
func ParseGetWalletKeyResponse(rsp *http.Response) (*GetWalletKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWalletKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetShelleyWalletMigrationInfoResponse parses an HTTP response from a GetShelleyWalletMigrationInfoWithResponse call
func ParseGetShelleyWalletMigrationInfoResponse(rsp *http.Response) (*GetShelleyWalletMigrationInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetShelleyWalletMigrationInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Leftovers dust coins which won't be migrated nor spent as fees.
			Leftovers struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"leftovers"`

			// Total amount which will be paid as fees for the migration.
			MigrationCost struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"migration_cost"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code string `json:"code"`

			// May occur when trying to migrate a wallet that is empty or full of dust.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseMigrateShelleyWalletResponse parses an HTTP response from a MigrateShelleyWalletWithResponse call
func ParseMigrateShelleyWalletResponse(rsp *http.Response) (*MigrateShelleyWalletResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MigrateShelleyWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParsePutWalletPassphraseResponse parses an HTTP response from a PutWalletPassphraseWithResponse call
func ParsePutWalletPassphraseResponse(rsp *http.Response) (*PutWalletPassphraseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutWalletPassphraseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParsePostTransactionFeeResponse parses an HTTP response from a PostTransactionFeeWithResponse call
func ParsePostTransactionFeeResponse(rsp *http.Response) (*PostTransactionFeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostTransactionFeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMax struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_max"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			EstimatedMin struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"estimated_min"`

			// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
			//
			//   - (a) Some updatable protocol parameters fixed by the network.
			//   - (b) The nature of the outputs (i.e. the kind of assets it includes).
			//
			// The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
			// are ordered in the same way** as **requested outputs** are ordered. In the case where there's no explicitly requested outputs (e.g.
			// when calculating fee for delegation), this list is empty.
			//
			// For example, an output containing only `Ada` may require to be of at least `1 Ada`. An output containing only an hypothetical `AppleCoin`
			// may require to also carry a minimum of `1.2 Ada`. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.
			//
			// > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
			// UTxO, they are given an intrinsic value indexed itself on the value of Ada.
			MinimumCoins []struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"minimum_coins"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseSignMetadataResponse parses an HTTP response from a SignMetadataWithResponse call
func ParseSignMetadataResponse(rsp *http.Response) (*SignMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SignMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code string `json:"code"`

			// May occur when a request is not well-formed; that is, it fails to parse
			// successfully. This could be the case when some required parameters
			// are missing or, when malformed values are provided.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {

			// A specific error code for this error, more precise than HTTP ones.
			Code string `json:"code"`

			// A descriptive error message.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseGetUTxOsStatisticsResponse parses an HTTP response from a GetUTxOsStatisticsWithResponse call
func ParseGetUTxOsStatisticsResponse(rsp *http.Response) (*GetUTxOsStatisticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUTxOsStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Distribution Distribution `json:"distribution"`
			Scale        string       `json:"scale"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Total struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListTransactionsResponse parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResponse(rsp *http.Response) (*ListTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParsePostTransactionResponse parses an HTTP response from a PostTransactionWithResponse call
func ParsePostTransactionResponse(rsp *http.Response) (*PostTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code string `json:"code"`

			// May occur when a given walletId does not match with any known
			// wallets (because it has been deleted, or has never existed).
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Content-Type' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code string `json:"code"`

			// Occurs when attempting to delete a transaction which is neither pending nor expired.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// An amount of Ada spent or received, from the perspective of the wallet.
			//
			// That is, for outgoing transaction, it represents the amount of Ada consumed
			// as inputs, minus the amount of Ada spent as fees, as deposits or to addresses
			// which do not belong to the wallet.
			//
			// For incoming transaction, it represents the total amount of Ada received to
			// addresses that belong to the wallet.
			Amount struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"amount"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Deposit struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"deposit"`

			// <span style="position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;">
			// <strong>if:</strong> status == in_ledger
			// </span><br/>
			// Current depth of the transaction in the local chain
			Depth *struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"depth,omitempty"`
			Direction string `json:"direction"`

			// A reference to a particular time slot.
			ExpiresAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"expires_at,omitempty"`

			// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
			Fee struct {
				Quantity int    `json:"quantity"`
				Unit     string `json:"unit"`
			} `json:"fee"`

			// A unique identifier for this transaction
			Id string `json:"id"`

			// A list of transaction inputs.
			//
			// `assets` and `address` are always present for `outgoing`
			// transactions but generally absent for `incoming`
			// transactions. This information is present on the Cardano explorer,
			// but is not tracked by the wallet.
			Inputs []struct {
				Address *string `json:"address,omitempty"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount *struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount,omitempty"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`

				// A unique identifier for this transaction
				Id    string `json:"id"`
				Index int    `json:"index"`
			} `json:"inputs"`

			// A reference to a particular time slot, and the block height at that point.
			InsertedAt *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"inserted_at,omitempty"`

			// **⚠️ WARNING ⚠️**
			//
			// _Please note that metadata provided in a transaction will be
			// stored on the blockchain forever. Make sure not to include any sensitive data,
			// in particular personally identifiable information (PII)._
			//
			// Extra application data attached to the transaction.
			//
			// Cardano allows users and developers to embed their own
			// authenticated metadata when submitting transactions. Metadata can
			// be expressed as a JSON object with some restrictions:
			//
			// 1. All top-level keys must be integers between `0` and `2^64 - 1`.
			//
			// 2. Each metadata value is tagged with its type.
			//
			// 3. Strings must be at most 64 bytes when UTF-8 encoded.
			//
			// 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
			//
			// Metadata aren't stored as JSON on the Cardano blockchain but are
			// instead stored using a compact binary encoding (CBOR).
			//
			// The binary encoding of metadata values supports three simple types:
			//
			// * Integers in the range `-(2^64 - 1)` to `2^64 - 1`
			// * Strings (UTF-8 encoded)
			// * Bytestrings
			//
			// And two compound types:
			//
			// * Lists of metadata values
			// * Mappings from metadata values to metadata values
			//
			// It is possible to transform any JSON object into this schema.
			//
			// However, if your application uses floating point values, they will
			// need to be converted somehow, according to your
			// requirements. Likewise for `null` or `bool` values. When reading
			// metadata from chain, be aware that integers may exceed the
			// javascript numeric range, and may need special "bigint" parsing.
			Metadata *Metadata `json:"metadata"`

			// <p>status: <strong>⚠ under development</strong></p>
			//
			// _This field is not implemented yet, and will always be empty._
			//
			// Assets minted (created) or unminted (destroyed)
			//
			// This amount contributes to the total transaction value.
			//
			// Positive values denote creation of assets and negative values
			// denote the reverse.
			Mint []struct {

				// The asset on-chain type which acts as a sub-identifier within a
				// policy. Although we call it "asset name", the value needn't be
				// text, and it could even be empty.
				//
				// For policies with a single fungible asset item, asset name is
				// typically an empty string.
				//
				// This value can be up to 32 bytes of arbitrary data (which is 64
				// hexadecimal digits).
				AssetName string `json:"asset_name"`

				// A user-facing short fingerprint which combines the `policy_id` and `asset_name`
				// to allow for an easier human comparison of assets. Note that it is generally
				// **not okay** to use this fingerprint as a unique identifier for it is not collision
				// resistant. Yet within the context of a single wallet, it makes for a (rather)
				// short user-facing comparison mean.
				Fingerprint *string `json:"fingerprint,omitempty"`

				// A unique identifier of the asset's monetary policy. The policy
				// controls how assets of this kind are created and destroyed.
				//
				// The contents are the blake2b-224 hash of the monetary policy
				// script, encoded in hexadecimal.
				PolicyId string `json:"policy_id"`

				// Positive values mean creation and negative values mean
				// destruction.
				Quantity int `json:"quantity"`
			} `json:"mint"`

			// A list of target outputs
			Outputs []struct {
				Address string `json:"address"`

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`

				// A flat list of assets.
				Assets *[]struct {

					// The asset on-chain type which acts as a sub-identifier within a
					// policy. Although we call it "asset name", the value needn't be
					// text, and it could even be empty.
					//
					// For policies with a single fungible asset item, asset name is
					// typically an empty string.
					//
					// This value can be up to 32 bytes of arbitrary data (which is 64
					// hexadecimal digits).
					AssetName string `json:"asset_name"`

					// A unique identifier of the asset's monetary policy. The policy
					// controls how assets of this kind are created and destroyed.
					//
					// The contents are the blake2b-224 hash of the monetary policy
					// script, encoded in hexadecimal.
					PolicyId string `json:"policy_id"`

					// Number of assets for the given `policy_id` and `asset_name`.
					Quantity int `json:"quantity"`
				} `json:"assets,omitempty"`
			} `json:"outputs"`

			// A reference to a particular time slot, and the block height at that point.
			PendingSince *struct {

				// The 0-based slot index starting from genesis of the blockchain.
				AbsoluteSlotNumber int `json:"absolute_slot_number"`

				// An epoch is a time period which is divided into slots.
				EpochNumber int `json:"epoch_number"`
				Height      struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"height"`

				// The zero-based slot index within an epoch.
				SlotNumber int    `json:"slot_number"`
				Time       string `json:"time"`
			} `json:"pending_since,omitempty"`

			// Current transaction status.
			//
			//   ```
			//          *---------*          *-----------*
			//          |         |---------->  EXPIRED  |
			//          |         |  (ttl)   *-----------*
			//   -------> PENDING |
			//          |         <----------------*
			//          |         |                |
			//          *---------*            (rollback)
			//               |                     |
			//          (in ledger)          *-----------*
			//               |               |           |
			//               *---------------> IN_LEDGER |
			//                               |           |
			//                               *-----------*
			//   ```
			Status string `json:"status"`

			// A list of withdrawals from stake addresses.
			Withdrawals []struct {

				// Coins, in Lovelace. Only relates to 'Ada'. Refer to `assets` for multi-assets wallets instead.
				Amount struct {
					Quantity int    `json:"quantity"`
					Unit     string `json:"unit"`
				} `json:"amount"`
				StakeAddress string `json:"stake_address"`
			} `json:"withdrawals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {
			Code string `json:"code"`

			// May occur when providing an invalid 'Accept' header.
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}
